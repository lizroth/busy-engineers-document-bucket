{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Busy Engineer's Document Bucket Welcome to the Busy Engineer's Document Bucket workshop. In this workshop, you will be guided through adding client-side encryption with KMS and the AWS Encryption SDK. Each exercise has step-by-step instructions. Each exercise also has a -complete version available to use as a reference. Background: The Document Bucket System The example system you will will work on is the Document Bucket. As you begin this workshop, this system uses DynamoDB and S3 to store , search , list , and retrieve documents with associated metadata. The bodies of each document are written as S3 objects. DynamoDB maintains a pointer to that object, along with associated metadata for that object. Additionally, DynamoDB is set up to maintain records of tags used to identify the document, so that you can search for documents that match a particular tag. After your work in the workshop is complete, you will have added client-side encryption with the AWS Encryption SDK and AWS KMS to the Document Bucket. Before data leaves the origin instance in store , it will be encrypted client-side. After the data is retrieve d, it will be decrypted client side with a permissions check and audit entry from AWS KMS. You will also explore options for binding and validating the metadata to the object. Exercises Here are the exercises in this workshop: Using the AWS Encryption SDK Adding multiple Master Keys to your encryption Using Encryption Context Getting Started Ready to start? Proceed to Getting Started to begin.","title":"Home"},{"location":"#the-busy-engineers-document-bucket","text":"Welcome to the Busy Engineer's Document Bucket workshop. In this workshop, you will be guided through adding client-side encryption with KMS and the AWS Encryption SDK. Each exercise has step-by-step instructions. Each exercise also has a -complete version available to use as a reference.","title":"The Busy Engineer's Document Bucket"},{"location":"#background-the-document-bucket-system","text":"The example system you will will work on is the Document Bucket. As you begin this workshop, this system uses DynamoDB and S3 to store , search , list , and retrieve documents with associated metadata. The bodies of each document are written as S3 objects. DynamoDB maintains a pointer to that object, along with associated metadata for that object. Additionally, DynamoDB is set up to maintain records of tags used to identify the document, so that you can search for documents that match a particular tag. After your work in the workshop is complete, you will have added client-side encryption with the AWS Encryption SDK and AWS KMS to the Document Bucket. Before data leaves the origin instance in store , it will be encrypted client-side. After the data is retrieve d, it will be decrypted client side with a permissions check and audit entry from AWS KMS. You will also explore options for binding and validating the metadata to the object.","title":"Background: The Document Bucket System"},{"location":"#exercises","text":"Here are the exercises in this workshop: Using the AWS Encryption SDK Adding multiple Master Keys to your encryption Using Encryption Context","title":"Exercises"},{"location":"#getting-started","text":"Ready to start? Proceed to Getting Started to begin.","title":"Getting Started"},{"location":"add-the-encryption-sdk/","text":"Exercise 1: Add the AWS Encryption SDK In this section, you will add client-side encryption using the AWS Encryption SDK and KMS to the Busy Engineer's Document Bucket. Background The Busy Engineer's Document Bucket is an example application meant to show some high-level examples of real world AWS patterns. This includes how to integrate client-side encryption using AWS KMS and the AWS Encryption SDK in application code. Right now, the Document Bucket supports storing files (or documents, or other blobs of data) in a private S3 bucket, and indexing them in DynamoDB. This allows Document Bucket users to share files with other users, or store them for retrieval later. The DynamoDB entries provide fast lookups to the content of the bucket, along with metadata context for each bucket item. This context allows storing additional information about the S3 item. Perhaps the origin user, the destination fleet, the project, or any other tag that would be useful to know without downloading and examining the item. DynamoDB is also configured to allow indexing on which documents have which keys. So, for example, it's a quick query to find out which documents in the bucket have been tagged with \"configuration\" as a piece of metadata about the object contents. Here's the API the Document Bucket supports: list : This operation queries DynamoDB for all entries for all items in the bucket, and their metadata. It returns the set of items that have been stored. store : This operation accepts a blob of bytes and a map of metadata context. It generates a unique identifier for the document. The identifier and associated metadata are written to DynamoDB. The bytes of the data are written to S3 under a key of that unique identifier. Any context metadata keys in DynamoDB are updated to include that new object identifier. retrieve : This operation accepts a unique identifier as an argument. First it looks that identifier up in DynamoDB and pulls the identifier and its context out. Then it retrieves that object from S3. It bundles these items together and returns them to the caller. search : This operation accepts a metadata key to search for. It then queries DynamoDB for the set of documents in the Document Bucket that have context matching that key. This operation then returns that set of document identifiers and their metadata. Once the desired document or documents have been identified with the returned metadata, the document identifiers can be passed to retrieve to actually fetch the documents. This is a start for sharing, storing, and searching documents of a variety of types. But what about sensitive documents? Or protecting, say, important configuration files from accidental corruption during storing or retrieving? Now you will add the AWS Encryption SDK to encrypt close to where the data originates: client-side encrypting the Document Bucket document before it is transmitted off of the host machine to the internet. You will use KMS to provide a data key for each document, using a CMK that you set up in Getting Started when you deployed your stacks. Make the Change Starting Directory Make sure you are in the exercises directory for the language of your choice: Java 1 cd ~/environment/workshop/exercises/java Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript Python 1 cd ~/environment/workshop/exercises/python cd into the add-esdk-start directory. Step 1: Add the ESDK Dependency Look for ADD-ESDK-START comments to help orient yourself in the code. Start by adding the Encryption SDK dependency to the code. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Edit Api.java package sfw.example.esdkworkshop ; // ADD-ESDK-START: Add the ESDK Dependency import com.amazonaws.encryptionsdk.AwsCrypto ; import com.amazonaws.encryptionsdk.CryptoResult ; import com.amazonaws.encryptionsdk.MasterKey ; import com.amazonaws.encryptionsdk.MasterKeyProvider ; import com.amazonaws.encryptionsdk.kms.KmsMasterKey ; ... // ADD-ESDK-START: Add the ESDK Dependency private final AwsCrypto awsEncryptionSdk ; private final MasterKeyProvider mkp ; ... public Api ( AmazonDynamoDB ddbClient , String tableName , AmazonS3 s3Client , String bucketName , // ADD-ESDK-START: Add the ESDK Dependency MasterKeyProvider <? extends MasterKey > mkp ) { this . ddbClient = ddbClient ; this . tableName = tableName ; this . s3Client = s3Client // ADD-ESDK-START: Add the ESDK Dependency this . awsEncryptionSdk = new AwsCrypto (); this . mkp = mkp ; } // Save and close. // Edit App.java package sfw.example.esdkworkshop ; // ADD-ESDK-START: Add the ESDK Dependency import com.amazonaws.encryptionsdk.kms.KmsMasterKeyProvider ; // Save and close. Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit ./store.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency import { encryptStream , KmsKeyringNode } from \"@aws-crypto/client-node\" ; // Save and exit // Edit ./retrieve.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency import { decryptStream , KmsKeyringNode } from \"@aws-crypto/client-node\" ; // Save and exit JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit ./store.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency const { encryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit // Edit ./retrieve.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency const { decryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Edit src/document_bucket/__init__.py # ADD-ESDK-START: Add the ESDK Dependency import aws_encryption_sdk # Save and exit # Edit src/document_bucket/api.py # ADD-ESDK-START: Add the ESDK Dependency import aws_encryption_sdk from aws_encryption_sdk import KMSMasterKeyProvider # Add a Master Key Provider to your __init__ # ADD-ESDK-START: Add the ESDK Dependency def __init__ ( self , bucket , table , master_key_provider : KMSMasterKeyProvider ): self . bucket = bucket self . table = table # ADD-ESDK-START: Add the ESDK Dependency self . master_key_provider = master_key_provider # Save and exit What Just Happened You just imported a dependency on the AWS Encryption SDK library in your code. You also changed the API to expect that a Keyring or Master Key Provider will be passed to your code to use in store and retrieve operations. Step 2: Add Encryption to store Now that you have the AWS Encryption SDK imported, start encrypting your data before storing it. Java 1 2 3 4 5 6 7 8 // Edit Api.java public PointerItem store ( byte [] data , Map < String , String > context ) { // ADD-ESDK-START: Add Encryption to store CryptoResult < byte [], KmsMasterKey > encryptedMessage = awsEncryptionSdk . encryptData ( mkp , data ); DocumentBundle bundle = DocumentBundle . fromDataAndContext ( encryptedMessage . getResult (), context ); writeItem ( bundle . getPointer ()); ... Typescript Node.JS 1 2 3 4 5 6 // Edit ./store.js // ADD-ESDK-START: Add Encryption to store const Body = fileStream . pipe ( encryptStream ( encryptKeyring )); // Save and exit JavaScript Node.JS 1 2 3 4 5 6 // Edit ./store.js // ADD-ESDK-START: Add Encryption to store const Body = fileStream . pipe ( encryptStream ( encryptKeyring )); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 # Edit src/document_bucket/api.py # Find the store function and edit it to add the Master Key Provider # and to write the encrypted data # ADD-ESDK-START: Add Encryption to store encrypted_data , header = aws_encryption_sdk . encrypt ( source = data , key_provider = self . master_key_provider , ) ... self . _write_object ( encrypted_data , item ) What Just Happened The application will now encrypt data client-side with the AWS Encryption SDK and KMS before storing it. Now, before storing data in the Document Bucket, it uses the AWS Encryption SDK to: Request a new data key using your keyring or Master Key Provider Encrypt that data for you Return the encrypted data in the AWS Encryption SDK message format Extract the ciphertext to pass to the AWS S3 SDK to store in S3 Step 3: Add Decryption to retrieve Now that the application will encrypt data before storing it, it will need to decrypt the data before returning it to the caller. At least for the data to be useful, anyway. Java 1 2 3 4 5 6 7 // Edit Api.java // Find retrieve(...) byte [] data = getObjectData ( key ); // ADD-ESDK-START: Add Decryption to retrieve CryptoResult < byte [], KmsMasterKey > decryptedMessage = awsEncryptionSdk . decryptData ( mkp , data ); ... return DocumentBundle . fromDataAndPointer ( decryptedMessage . getResult (), pointer ); Typescript Node.JS 1 2 3 4 5 6 7 8 9 // Edit retrieve.js // ADD-ESDK-START: Add Decryption to retrieve return s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )); // Save and Exit JavaScript Node.JS 1 2 3 4 5 6 7 8 9 // Edit retrieve.js // ADD-ESDK-START: Add Decryption to retrieve return s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )); // Save and Exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/api.py # Find the retrieve function and edit it to add a call to decrypt the # encrypted data before returning it item = self . _get_pointer_item ( PointerQuery . from_key ( pointer_key )) # ADD-ESDK-START: Add Decryption to retrieve encrypted_data = self . _get_object ( item ) plaintext , header = aws_encryption_sdk . decrypt ( source = encrypted_data , key_provider = self . master_key_provider ) return DocumentBundle . from_data_and_context ( plaintext , item . context ) # Save and exit What Just Happened The application now decrypts data client-side as well. The data returned from S3 for retrieve is now encrypted. Before returning that data to the user, you added a call to the AWS Encryption SDK to decrypt the data. Under the hood, the Encryption SDK: Read the AWS Encryption SDK formatted encrypted message Called KMS to request to decrypt your message's encrypted data key using the Faythe CMK Used the decrypted data key to decrypt the message Returned the message plaintext and Encryption SDK headers to you Step 4: Configure the Faythe CMK in the Encryption SDK Now that you have your dependencies declared and your code updated to encrypt and decrypt data, the final step is to pass through the configuration to the AWS Encryption SDK to start using your KMS CMKs to protect your data. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit App.java AmazonS3 s3Client = AmazonS3ClientBuilder . defaultClient (); // ADD-ESDK-START: Configure the Faythe CMK in the Encryption SDK // Load configuration of KMS resources String faytheCMK = state . contents . FaytheCMK ; // Set up the Master Key Provider to use KMS KmsMasterKeyProvider mkp = KmsMasterKeyProvider . builder (). withKeysForEncryption ( faytheCMK ). build (); // Construct the API return new Api ( ddbClient , tableName , s3Client , bucketName , mkp ); Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Edit store.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK }); // Save and exit // Edit retrieve.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK ] }); // Save and exit JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Edit store.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK }); // Save and exit // Edit retrieve.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK ] }); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/__init__.py ... # ADD-ESDK-START: Configure the Faythe CMK in the Encryption SDK # Pull configuration of KMS resources faythe_cmk = state [ \"FaytheCMK\" ] # And the Master Key Provider configuring how to use KMS cmk = [ faythe_cmk ] mkp = aws_encryption_sdk . KMSMasterKeyProvider ( key_ids = cmk ) operations = DocumentBucketOperations ( bucket , table , mkp ) # Save and exit What Just Happened In Getting Started, you launched CloudFormation stacks for CMKs. One of these CMKs was nicknamed Faythe. As part of launching these templates, the CMK's Amazon Resource Name (ARN) was written to a configuration file on disk, the state variable that is loaded and parsed. Now Faythe's ARN is pulled into a variable, and used to initialize a keyring or master key provider that will use the Faythe CMK. That new keyring/master key provider is passed in to your API, and you are set to start encrypting and decrypting with KMS and the Encryption SDK. Checking Your Work Want to check your progress, or compare what you've done versus a finished example? Check out the code in one of the -complete folders to compare. Java 1 cd ~/environment/workshop/exercises/java/add-esdk-complete Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript/add-esdk-complete JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript/add-esdk-complete Python 1 cd ~/environment/workshop/exercises/python/add-esdk-complete Try it Out Now that the code is written, let's load it up and try it out. If you'd like to try a finished example, use your language's -complete directory as described above. Experiment using the API as much as you like. To get you started, here are some suggested things to try. Compare CloudTrail Logs for usages of Faythe when you encrypt messages of different sizes (small, medium, large). Take a look at the contents of your S3 Document Bucket to inspect the raw object. If you want more ideas to extend, check out Explore Further below. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // To use the API programmatically, use this target to launch jshell mvn jshell : run / open startup . jsh Api documentBucket = App . initializeDocumentBucket (); documentBucket . list (); documentBucket . store ( \"Store me in the Document Bucket!\" . getBytes ()); for ( PointerItem item : documentBucket . list ()) { DocumentBundle document = documentBucket . retrieve ( item . partitionKey ()); System . out . println ( document . toString ()); } // Ctrl+D to exit jshell // Or, to run logic that you write in App.java, use this target mvn compile JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL JavaScript Node.JS CLI 1 2 3 4 5 6 ./cli.js list ./cli.js store ./store.js # Note the \"Key\" value ./cli.js list # Note the \"reference\" value ./cli.js retrieve $KeyOrReferenceValue Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 node - r ts - node / register ;({ list } = require ( \"./src/list.ts\" )) ;({ store } = require ( \"./src/store.ts\" )) list (). then ( console . log ) store ( fs . createReadStream ( \"./src/store.ts\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL Typescript Node.JS CLI 1 2 3 4 5 6 ./cli.ts list ./cli.ts store ./store.js # Note the \"Key\" value ./cli.ts list # Note the \"reference\" value ./cli.ts retrieve $KeyOrReferenceValue Python 1 2 3 4 5 6 7 tox - e repl import document_bucket ops = document_bucket . initialize () ops . list () ops . store ( b 'some data' ) ops . list () # Ctrl-D when finished to exit the REPL Explore Further Leveraging the Message Format - The AWS Encryption SDK Message Format is an open standard. Can you write something to detect whether an entry in the Document Bucket has been encrypted in this format or not, and retrieve or decrypt appropriately? More Test Content - Small test strings are enough to get started, but you might be curious to see what the behavior and performance looks like with larger documents. What if you add support for loading files to and from disk to the Document Bucket? Configuration Glue - If you are curious how the Document Bucket is configured, take a peek at ~/environment/workshop/cdk/Makefile and the make state target, as well as config.toml in the exercises root ~/environment/workshop/exercises/config.toml . The Busy Engineer's Document Bucket uses a base TOML file to set standard names for all CloudFormation resources and a common place to discover the real deployed set. Then it uses the AWS Cloud Development Kit (CDK) to deploy the resources and write out their identifiers to the state file. Applications use the base TOML file config.toml to locate the state file and pull the expected resource names. And that's how the system bootstraps all the resources it needs! Next exercise Now that you are encrypting and decrypting, how about adding Multiple CMKs ?","title":"Add the Encryption SDK"},{"location":"add-the-encryption-sdk/#exercise-1-add-the-aws-encryption-sdk","text":"In this section, you will add client-side encryption using the AWS Encryption SDK and KMS to the Busy Engineer's Document Bucket.","title":"Exercise 1: Add the AWS Encryption SDK"},{"location":"add-the-encryption-sdk/#background","text":"The Busy Engineer's Document Bucket is an example application meant to show some high-level examples of real world AWS patterns. This includes how to integrate client-side encryption using AWS KMS and the AWS Encryption SDK in application code. Right now, the Document Bucket supports storing files (or documents, or other blobs of data) in a private S3 bucket, and indexing them in DynamoDB. This allows Document Bucket users to share files with other users, or store them for retrieval later. The DynamoDB entries provide fast lookups to the content of the bucket, along with metadata context for each bucket item. This context allows storing additional information about the S3 item. Perhaps the origin user, the destination fleet, the project, or any other tag that would be useful to know without downloading and examining the item. DynamoDB is also configured to allow indexing on which documents have which keys. So, for example, it's a quick query to find out which documents in the bucket have been tagged with \"configuration\" as a piece of metadata about the object contents. Here's the API the Document Bucket supports: list : This operation queries DynamoDB for all entries for all items in the bucket, and their metadata. It returns the set of items that have been stored. store : This operation accepts a blob of bytes and a map of metadata context. It generates a unique identifier for the document. The identifier and associated metadata are written to DynamoDB. The bytes of the data are written to S3 under a key of that unique identifier. Any context metadata keys in DynamoDB are updated to include that new object identifier. retrieve : This operation accepts a unique identifier as an argument. First it looks that identifier up in DynamoDB and pulls the identifier and its context out. Then it retrieves that object from S3. It bundles these items together and returns them to the caller. search : This operation accepts a metadata key to search for. It then queries DynamoDB for the set of documents in the Document Bucket that have context matching that key. This operation then returns that set of document identifiers and their metadata. Once the desired document or documents have been identified with the returned metadata, the document identifiers can be passed to retrieve to actually fetch the documents. This is a start for sharing, storing, and searching documents of a variety of types. But what about sensitive documents? Or protecting, say, important configuration files from accidental corruption during storing or retrieving? Now you will add the AWS Encryption SDK to encrypt close to where the data originates: client-side encrypting the Document Bucket document before it is transmitted off of the host machine to the internet. You will use KMS to provide a data key for each document, using a CMK that you set up in Getting Started when you deployed your stacks.","title":"Background"},{"location":"add-the-encryption-sdk/#make-the-change","text":"","title":"Make the Change"},{"location":"add-the-encryption-sdk/#starting-directory","text":"Make sure you are in the exercises directory for the language of your choice: Java 1 cd ~/environment/workshop/exercises/java Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript Python 1 cd ~/environment/workshop/exercises/python cd into the add-esdk-start directory.","title":"Starting Directory"},{"location":"add-the-encryption-sdk/#step-1-add-the-esdk-dependency","text":"Look for ADD-ESDK-START comments to help orient yourself in the code. Start by adding the Encryption SDK dependency to the code. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Edit Api.java package sfw.example.esdkworkshop ; // ADD-ESDK-START: Add the ESDK Dependency import com.amazonaws.encryptionsdk.AwsCrypto ; import com.amazonaws.encryptionsdk.CryptoResult ; import com.amazonaws.encryptionsdk.MasterKey ; import com.amazonaws.encryptionsdk.MasterKeyProvider ; import com.amazonaws.encryptionsdk.kms.KmsMasterKey ; ... // ADD-ESDK-START: Add the ESDK Dependency private final AwsCrypto awsEncryptionSdk ; private final MasterKeyProvider mkp ; ... public Api ( AmazonDynamoDB ddbClient , String tableName , AmazonS3 s3Client , String bucketName , // ADD-ESDK-START: Add the ESDK Dependency MasterKeyProvider <? extends MasterKey > mkp ) { this . ddbClient = ddbClient ; this . tableName = tableName ; this . s3Client = s3Client // ADD-ESDK-START: Add the ESDK Dependency this . awsEncryptionSdk = new AwsCrypto (); this . mkp = mkp ; } // Save and close. // Edit App.java package sfw.example.esdkworkshop ; // ADD-ESDK-START: Add the ESDK Dependency import com.amazonaws.encryptionsdk.kms.KmsMasterKeyProvider ; // Save and close. Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit ./store.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency import { encryptStream , KmsKeyringNode } from \"@aws-crypto/client-node\" ; // Save and exit // Edit ./retrieve.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency import { decryptStream , KmsKeyringNode } from \"@aws-crypto/client-node\" ; // Save and exit JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit ./store.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency const { encryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit // Edit ./retrieve.js // ADD-ESDK-START: Add the @aws-crypto/client-node dependency const { decryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Edit src/document_bucket/__init__.py # ADD-ESDK-START: Add the ESDK Dependency import aws_encryption_sdk # Save and exit # Edit src/document_bucket/api.py # ADD-ESDK-START: Add the ESDK Dependency import aws_encryption_sdk from aws_encryption_sdk import KMSMasterKeyProvider # Add a Master Key Provider to your __init__ # ADD-ESDK-START: Add the ESDK Dependency def __init__ ( self , bucket , table , master_key_provider : KMSMasterKeyProvider ): self . bucket = bucket self . table = table # ADD-ESDK-START: Add the ESDK Dependency self . master_key_provider = master_key_provider # Save and exit","title":"Step 1: Add the ESDK Dependency"},{"location":"add-the-encryption-sdk/#what-just-happened","text":"You just imported a dependency on the AWS Encryption SDK library in your code. You also changed the API to expect that a Keyring or Master Key Provider will be passed to your code to use in store and retrieve operations.","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#step-2-add-encryption-to-store","text":"Now that you have the AWS Encryption SDK imported, start encrypting your data before storing it. Java 1 2 3 4 5 6 7 8 // Edit Api.java public PointerItem store ( byte [] data , Map < String , String > context ) { // ADD-ESDK-START: Add Encryption to store CryptoResult < byte [], KmsMasterKey > encryptedMessage = awsEncryptionSdk . encryptData ( mkp , data ); DocumentBundle bundle = DocumentBundle . fromDataAndContext ( encryptedMessage . getResult (), context ); writeItem ( bundle . getPointer ()); ... Typescript Node.JS 1 2 3 4 5 6 // Edit ./store.js // ADD-ESDK-START: Add Encryption to store const Body = fileStream . pipe ( encryptStream ( encryptKeyring )); // Save and exit JavaScript Node.JS 1 2 3 4 5 6 // Edit ./store.js // ADD-ESDK-START: Add Encryption to store const Body = fileStream . pipe ( encryptStream ( encryptKeyring )); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 # Edit src/document_bucket/api.py # Find the store function and edit it to add the Master Key Provider # and to write the encrypted data # ADD-ESDK-START: Add Encryption to store encrypted_data , header = aws_encryption_sdk . encrypt ( source = data , key_provider = self . master_key_provider , ) ... self . _write_object ( encrypted_data , item )","title":"Step 2: Add Encryption to store"},{"location":"add-the-encryption-sdk/#what-just-happened_1","text":"The application will now encrypt data client-side with the AWS Encryption SDK and KMS before storing it. Now, before storing data in the Document Bucket, it uses the AWS Encryption SDK to: Request a new data key using your keyring or Master Key Provider Encrypt that data for you Return the encrypted data in the AWS Encryption SDK message format Extract the ciphertext to pass to the AWS S3 SDK to store in S3","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#step-3-add-decryption-to-retrieve","text":"Now that the application will encrypt data before storing it, it will need to decrypt the data before returning it to the caller. At least for the data to be useful, anyway. Java 1 2 3 4 5 6 7 // Edit Api.java // Find retrieve(...) byte [] data = getObjectData ( key ); // ADD-ESDK-START: Add Decryption to retrieve CryptoResult < byte [], KmsMasterKey > decryptedMessage = awsEncryptionSdk . decryptData ( mkp , data ); ... return DocumentBundle . fromDataAndPointer ( decryptedMessage . getResult (), pointer ); Typescript Node.JS 1 2 3 4 5 6 7 8 9 // Edit retrieve.js // ADD-ESDK-START: Add Decryption to retrieve return s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )); // Save and Exit JavaScript Node.JS 1 2 3 4 5 6 7 8 9 // Edit retrieve.js // ADD-ESDK-START: Add Decryption to retrieve return s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )); // Save and Exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/api.py # Find the retrieve function and edit it to add a call to decrypt the # encrypted data before returning it item = self . _get_pointer_item ( PointerQuery . from_key ( pointer_key )) # ADD-ESDK-START: Add Decryption to retrieve encrypted_data = self . _get_object ( item ) plaintext , header = aws_encryption_sdk . decrypt ( source = encrypted_data , key_provider = self . master_key_provider ) return DocumentBundle . from_data_and_context ( plaintext , item . context ) # Save and exit","title":"Step 3: Add Decryption to retrieve"},{"location":"add-the-encryption-sdk/#what-just-happened_2","text":"The application now decrypts data client-side as well. The data returned from S3 for retrieve is now encrypted. Before returning that data to the user, you added a call to the AWS Encryption SDK to decrypt the data. Under the hood, the Encryption SDK: Read the AWS Encryption SDK formatted encrypted message Called KMS to request to decrypt your message's encrypted data key using the Faythe CMK Used the decrypted data key to decrypt the message Returned the message plaintext and Encryption SDK headers to you","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#step-4-configure-the-faythe-cmk-in-the-encryption-sdk","text":"Now that you have your dependencies declared and your code updated to encrypt and decrypt data, the final step is to pass through the configuration to the AWS Encryption SDK to start using your KMS CMKs to protect your data. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit App.java AmazonS3 s3Client = AmazonS3ClientBuilder . defaultClient (); // ADD-ESDK-START: Configure the Faythe CMK in the Encryption SDK // Load configuration of KMS resources String faytheCMK = state . contents . FaytheCMK ; // Set up the Master Key Provider to use KMS KmsMasterKeyProvider mkp = KmsMasterKeyProvider . builder (). withKeysForEncryption ( faytheCMK ). build (); // Construct the API return new Api ( ddbClient , tableName , s3Client , bucketName , mkp ); Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Edit store.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK }); // Save and exit // Edit retrieve.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK ] }); // Save and exit JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Edit store.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK }); // Save and exit // Edit retrieve.js // ADD-ESDK-START: Set up a keyring to use Faythe's CMK for decrypting. const faytheCMK = config . state . getFaytheCMK (); const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK ] }); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/__init__.py ... # ADD-ESDK-START: Configure the Faythe CMK in the Encryption SDK # Pull configuration of KMS resources faythe_cmk = state [ \"FaytheCMK\" ] # And the Master Key Provider configuring how to use KMS cmk = [ faythe_cmk ] mkp = aws_encryption_sdk . KMSMasterKeyProvider ( key_ids = cmk ) operations = DocumentBucketOperations ( bucket , table , mkp ) # Save and exit","title":"Step 4: Configure the Faythe CMK in the Encryption SDK"},{"location":"add-the-encryption-sdk/#what-just-happened_3","text":"In Getting Started, you launched CloudFormation stacks for CMKs. One of these CMKs was nicknamed Faythe. As part of launching these templates, the CMK's Amazon Resource Name (ARN) was written to a configuration file on disk, the state variable that is loaded and parsed. Now Faythe's ARN is pulled into a variable, and used to initialize a keyring or master key provider that will use the Faythe CMK. That new keyring/master key provider is passed in to your API, and you are set to start encrypting and decrypting with KMS and the Encryption SDK.","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#checking-your-work","text":"Want to check your progress, or compare what you've done versus a finished example? Check out the code in one of the -complete folders to compare. Java 1 cd ~/environment/workshop/exercises/java/add-esdk-complete Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript/add-esdk-complete JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript/add-esdk-complete Python 1 cd ~/environment/workshop/exercises/python/add-esdk-complete","title":"Checking Your Work"},{"location":"add-the-encryption-sdk/#try-it-out","text":"Now that the code is written, let's load it up and try it out. If you'd like to try a finished example, use your language's -complete directory as described above. Experiment using the API as much as you like. To get you started, here are some suggested things to try. Compare CloudTrail Logs for usages of Faythe when you encrypt messages of different sizes (small, medium, large). Take a look at the contents of your S3 Document Bucket to inspect the raw object. If you want more ideas to extend, check out Explore Further below. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // To use the API programmatically, use this target to launch jshell mvn jshell : run / open startup . jsh Api documentBucket = App . initializeDocumentBucket (); documentBucket . list (); documentBucket . store ( \"Store me in the Document Bucket!\" . getBytes ()); for ( PointerItem item : documentBucket . list ()) { DocumentBundle document = documentBucket . retrieve ( item . partitionKey ()); System . out . println ( document . toString ()); } // Ctrl+D to exit jshell // Or, to run logic that you write in App.java, use this target mvn compile JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL JavaScript Node.JS CLI 1 2 3 4 5 6 ./cli.js list ./cli.js store ./store.js # Note the \"Key\" value ./cli.js list # Note the \"reference\" value ./cli.js retrieve $KeyOrReferenceValue Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 node - r ts - node / register ;({ list } = require ( \"./src/list.ts\" )) ;({ store } = require ( \"./src/store.ts\" )) list (). then ( console . log ) store ( fs . createReadStream ( \"./src/store.ts\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL Typescript Node.JS CLI 1 2 3 4 5 6 ./cli.ts list ./cli.ts store ./store.js # Note the \"Key\" value ./cli.ts list # Note the \"reference\" value ./cli.ts retrieve $KeyOrReferenceValue Python 1 2 3 4 5 6 7 tox - e repl import document_bucket ops = document_bucket . initialize () ops . list () ops . store ( b 'some data' ) ops . list () # Ctrl-D when finished to exit the REPL","title":"Try it Out"},{"location":"add-the-encryption-sdk/#explore-further","text":"Leveraging the Message Format - The AWS Encryption SDK Message Format is an open standard. Can you write something to detect whether an entry in the Document Bucket has been encrypted in this format or not, and retrieve or decrypt appropriately? More Test Content - Small test strings are enough to get started, but you might be curious to see what the behavior and performance looks like with larger documents. What if you add support for loading files to and from disk to the Document Bucket? Configuration Glue - If you are curious how the Document Bucket is configured, take a peek at ~/environment/workshop/cdk/Makefile and the make state target, as well as config.toml in the exercises root ~/environment/workshop/exercises/config.toml . The Busy Engineer's Document Bucket uses a base TOML file to set standard names for all CloudFormation resources and a common place to discover the real deployed set. Then it uses the AWS Cloud Development Kit (CDK) to deploy the resources and write out their identifiers to the state file. Applications use the base TOML file config.toml to locate the state file and pull the expected resource names. And that's how the system bootstraps all the resources it needs!","title":"Explore Further"},{"location":"add-the-encryption-sdk/#next-exercise","text":"Now that you are encrypting and decrypting, how about adding Multiple CMKs ?","title":"Next exercise"},{"location":"encryption-context/","text":"Exercise 3: Working With Encryption Context In this section, you will work with encryption context and explore its use in the Document Bucket and other applications. Background The Busy Engineer's Document Bucket has metadata, called context , associated with each document. This meatadata is a set of key-value string pairs, associated with the item in DynamoDB, searchable there, and attached to the S3 object as well. One of the features AWS KMS and the AWS Encryption SDK both provide is called encryption context. At its core, encryption context is this metadata mapping: keys that are associated with context about the object, and values indicating information about what that context is. All the information in the map is non-secret, and is the basis for several feature integrations. One useful model for thinking about encryption context is as Assertions about the Five Ws : Who, What, Where, When, Why. For example: Who should have access to this decrypted data? What data is being decrypted? Where is the decryption happening? When is this data being used? Why is this data being decrypted? AWS KMS: KMS Operations and Encryption Context AWS KMS allows you to specify an encryption context on kms:Encrypt . If you do so, you must provide the exact same encryption context on kms:Decrypt , or the operation will fail. (The match is case-sensitive, and key-value pairs are compared in an order independent way.) Behind the scenes, KMS is cryptographically binding the encryption context to the key material you are kms:Encrypt or kms:Decrypt ing as Additional Authenticated Data (AAD) . In short, this is non-secret data that must be identical (not tampered-with or incomplete), or decryption fails. This feature defends against risks from ciphertexts being tampered with, modified, or replaced -- intentionally or unintentionally. It both defends against an attacker replacing one ciphertext with another as well as problems like operational events. For example, if a bad deployment swaps us-west-2.cfg with eu-central-1.cfg on your fleets, having { fleet: us-west-2 } asserted in us-west-2.cfg 's encryption context will prevent it from accidentally being loaded by eu-central-1 . AWS KMS: Policy and Audit Hooks KMS also makes the encryption context available to use in Key Policies and Grants. This means that you can use assertions you make about your data to control usage of your CMKs. Perhaps your eu-central-1 fleet should only ever be permitted to access encrypted data for { shard: europe } . You can write CMK policies that require { shard: europe } to be asserted about all cryptographic operations, so that KMS refuses to authorize an attempt to decrypt, say, { shard: north-america } . These options can help you secure your application and defend against both operational and security-related risks. Additionally, as part of the audit features that KMS provides, it logs the encryption context that was supplied with every operation. You can use this information to audit who was accessing what data and when, to detect anomalous call patterns, or to identify unexpected system states. What questions would you like to answer with CloudTrail Logs for your KMS operations? encryption context can help. The AWS Encryption SDK The AWS Encryption SDK includes the encryption context as a core component. Encryption context may be supplied on encrypt -- it is optional, both for the Encryption SDK and for KMS, but strongly recommended. The Encryption SDK writes the encryption context in the encrypted message format. And on decrypt, the Encryption SDK validates the encryption context with KMS and returns the contents to you for you to make assertions about the contents. Using the Encryption SDK with KMS, you can use all of KMS' policy and audit features from encryption context, and use the Encryption SDK to make assertions to safeguard your application. Use in the Document Bucket So how can encryption context be useful in the Document Bucket? In this exercise, you will walk through a few examples of how leveraging encryption context can help you secure and audit your application, and even build some convenience features. The Document Bucket already has the context map available for operations. It writes the context to the DynamoDB records for objects as well, and generates searchable DynamoDB records for context keys, to let you find documents that have certain attributes. Now you will plumb that context through the AWS Encryption SDK, so that KMS and the Encryption SDK bind those properties as security assertions about your data. You will also add an assertion facility to ensure that your data is what you expect it to be when you call retrieve . What this means is that with this change, you will be able to use encryption context to defend against these kind of risks: DynamoDB record updates that create metadata mismatches between a document and its properties Swapping objects in S3 so that the data is no longer what it was expected to be Accidentally loading the wrong data blob Defending against objects being listed as having a certain context key / property when they actually do not Also, after this change, the contents of context will be available in audit log entries written by KMS, and you can now use that metadata in your Key Policies and Grants. Remember, encryption context is not secret! Make the Change Starting Directory If you just finished Using Multiple CMKs , you are all set. If you aren't sure, or want to catch up, jump into the encryption-context-start directory for the language of your choice. Java 1 cd ~/environment/workshop/java/encryption-context-start Typescript Node.JS 1 cd ~/environment/workshop/node-typescript/encryption-context-start JavaScript Node.JS 1 cd ~/environment/workshop/node-javascript/encryption-context-start Python 1 cd ~/environment/workshop/python/encryption-context-start Step 1: Set Encryption Context on Encrypt Java 1 2 3 4 5 6 7 // Edit Api.java and find store(...) // ENCRYPTION-CONTEXT-START: Set Encryption Context on Encrypt CryptoResult < byte [], KmsMasterKey > encryptedMessage = awsEncryptionSdk . encryptData ( mkp , data , context ); DocumentBundle bundle = DocumentBundle . fromDataAndContext ( encryptedMessage . getResult (), context ); // Save your changes JavaScript Node.JS 1 2 3 4 5 6 7 // Edit store.js // ENCRYPTION-CONTEXT-COMPLETE: Set encryption context on Encrypt const Body = fileStream . pipe ( encryptStream ( encryptKeyring , { encryptionContext }) ); // Save your changes Typescript Node.JS 1 2 3 4 5 6 7 // Edit src/store.ts // ENCRYPTION-CONTEXT-COMPLETE: Set encryption context on Encrypt const Body = fileStream . pipe ( encryptStream ( encryptKeyring , { encryptionContext }) ); // Save your changes Python 1 2 3 4 5 6 7 8 9 10 # Edit src/document_bucket/api.py # Find the store(...) function, and add context to the encrypt call # ENCRYPTION-CONTEXT-START: Set encryption context on Encrypt encrypted_data , header = aws_encryption_sdk . encrypt ( source = data , key_provider = self . master_key_provider , encryption_context = context , ) # Save your changes What Just Happened The Document Bucket context will now be supplied to the AWS Encryption SDK and AWS KMS as encryption context. If a non-empty key-value pair map is supplied to store , those key-value pairs will be used in encryption and decryption operations all the way through to KMS: The contents of context will appear in KMS audit logs. The contents of context will be availble to use in KMS Key Policies and Grants to make authorization decisions. The contents of context will be written to the Encryption SDK message. Supplying the exact-match contents of context will be required to decrypt any encrypted data keys. The contents of context will now be available on Decrypt to use in making assertions. Next you will update retrieve to use the encryption context on decrypt. Step 2: Use Encryption Context on Decrypt Java 1 2 3 4 5 // Edit Api.java and find retrieve(...) // ENCRYPTION-CONTEXT-START: Use Encryption Context on Decrypt Map < String , String > actualContext = decryptedMessage . getEncryptionContext (); PointerItem pointer = PointerItem . fromKeyAndContext ( key , actualContext ); // Save your changes JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Edit retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( header ) { }) ); // Save your changes Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit src/retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( this : Writable , header : MessageHeader ) { }) ); // Save your changes Python 1 2 3 4 5 6 7 8 9 # Edit src/document_bucket/api.py # Find the retrieve(...) function, and use the Encryption SDK header's encryption # context to construct the DocumentBundle to return # ENCRYPTION-CONTEXT-START: Use encryption context on Decrypt return DocumentBundle . from_data_and_context ( plaintext , header . encryption_context ) # Save your changes What Just Happened Now on decrypt, the validated encryption context from the Encryption SDK Message Format header will be passed back to the application. Any business logic that would benefit from using the encryption context data for making decisions can use the version bound and validated by the Encryption SDK and KMS. Next you will add a mechanism for the application to test assertions made in encryption context before working with the returned data. Step 3: Making Assertions Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Edit Api.java and find retrieve(...) // ENCRYPTION-CONTEXT-START: Making Assertions boolean allExpectedContextKeysFound = actualContext . keySet (). containsAll ( expectedContextKeys ); if (! allExpectedContextKeysFound ) { // Remove all of the keys that were found expectedContextKeys . removeAll ( actualContext . keySet ()); String error = String . format ( \"Expected context keys were not found in the actual encryption context! \" + \"Missing keys were: %s\" , expectedContextKeys . toString ()); throw new DocumentBucketException ( error , new NoSuchElementException ()); } boolean allExpectedContextFound = actualContext . entrySet (). containsAll ( expectedContext . entrySet ()); if (! allExpectedContextFound ) { Set < Map . Entry < String , String >> expectedContextEntries = expectedContext . entrySet (); expectedContextEntries . removeAll ( actualContext . entrySet ()); String error = String . format ( \"Expected context pairs were not found in the actual encryption context! \" + \"Missing pairs were: %s\" , expectedContextEntries . toString ()); throw new DocumentBucketException ( error , new NoSuchElementException ()); } // Save your work JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Edit retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( header ) { const { encryptionContext } = header ; const pairs = Object . entries ( expectedContext || {}); const keys = ( expectedContextKeys || []). slice (); if ( ! ( pairs . every (([ key , value ]) => encryptionContext [ key ] === value ) && keys . every ( key => Object . hasOwnProperty . call ( encryptionContext , key ) ) ) ) { this . emit ( \"error\" , new Error ( \"Encryption context does not match expected shape\" ) ); } }) ); // Save your changes Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Edit src/retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( this : Writable , header : MessageHeader ) { const { encryptionContext } = header ; const pairs = Object . entries ( expectedContext || {}); const keys = ( expectedContextKeys || []). slice (); if ( ! ( pairs . every (([ key , value ]) => encryptionContext [ key ] === value ) && keys . every ( key => Object . hasOwnProperty . call ( encryptionContext , key ) ) ) ) { this . emit ( \"error\" , new Error ( \"Encryption context does not match expected shape\" ) ); } }) ); // Save your changes Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Edit src/document_bucket/api.py # Find the retrieve(...) function, and add some assertions about the contents # of the encryption context validated by the Encryption SDK # ENCRYPTION-CONTEXT-START: Making Assertions if not expected_context_keys <= header . encryption_context . keys (): error_msg = ( \"Encryption context assertion failed! \" f \"Expected all these keys: {expected_context_keys}, \" f \"but got {header.encryption_context}!\" ) raise AssertionError ( error_msg ) if not expected_context . items () <= header . encryption_context . items (): error_msg = ( \"Encryption context assertion failed! \" f \"Expected {expected_context}, \" f \"but got {header.encryption_context}!\" ) raise AssertionError ( error_msg ) What Just Happened retrieve will use its \"expected context keys\" argument to validate that all of those keys (with any associated values) are present in the encryption context. retrieve will also use its \"expected context\" argument to validate that the exact key-value pairs specified in expected context are present in the actual encryption context. If either of those assumptions is invalid, retrieve will raise an exception before returning the data. These assertions safeguard against accidentally returning unintended, corrupted, or tampered data to the application. Now the Document Bucket will use AWS KMS and the AWS Encryption SDK to ensure that the context metadata is consistent throughout the lifetime of the objects, resistant to tampering or corruption, and make the validated context available to the application logic to make additional business logic assertions safely. Checking Your Work If you want to check your progress, or compare what you've done versus a finished example, check out the code in one of the -complete folders to compare. There is a -complete folder for each language. Java 1 cd ~/environment/workshop/exercises/java/encryption-context-complete Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript/encryption-context-complete JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript/encryption-context-complete Python 1 cd ~/environment/workshop/exercises/python/encryption-context-complete Try it Out Now that you pass encryption context all the way through to KMS and validate it on return, what assertions do you want to make about your data? Here's some ideas for things to test: Expecting exact match of key-value pairs for keys like stage , shard , and source-fleet Expecting a set of keys to be present like submit-date and category Expecting an exact match of a subset of the supplied key-value pairs (e.g. only stage and shard , not source-fleet ) Doing the same for expected keys with any value Adding a constraint of a new key that you didn't supply at encryption time Adding a constraint with a different value, like stage=production Changing capitalization Using sorted versus unsorted mappings, such as java.util.SortedMap<K, V> in Java or collections.OrderedDict in Python There's a few simple suggestions to get you started in the snippets below. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // To use the API programmatically, use this target to launch jshell mvn jshell:run /open startup.jsh import java.util.HashMap ; Api documentBucket = App.initializeDocumentBucket () ; HashMap<String, String> context = new HashMap<String, String> () ; context.put ( \"shard\" , \"test\" ) ; context.put ( \"app\" , \"document-bucket\" ) ; context.put ( \"origin\" , \"development\" ) ; documentBucket.list () ; documentBucket.store ( \"Store me in the Document Bucket!\" .getBytes () , context ) ; for ( PointerItem item : documentBucket.list ()) { DocumentBundle document = documentBucket.retrieve ( item.partitionKey () , context ) ; System.out.println ( document.toString ()) ; } // Ctrl+D to exit jshell // Or, to run logic that you write in App.java, use this target mvn compile JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) list (). then ( console . log ) encryptionContext = { stage : \"demo\" , purpose : \"simple demonstration\" , origin : \"us-east-2\" } store ( fs . createReadStream ( \"./store.js\" ), encryptionContext ). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key , { expectedContext : { stage : \"demo\" }, expectedContextKeys : [ \"purpose\" ] }). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL JavaScript Node.JS CLI 1 2 3 4 5 6 7 8 9 10 11 ./cli.js list ./cli.js store ./store.js \\ -c \"stage:demo\" \\ -c \"purpose:simple demonstration\" \\ -c \"origin:us-east-2\" # Note the \"Key\" value ./cli.js list # Note the \"reference\" value ./cli.js retrieve $KeyOrReferenceValue \\ -c \"stage:demo\" \\ -k purpose Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 node - r ts - node / register ;({ list } = require ( \"./src/list.ts\" )) ;({ store } = require ( \"./src/store.ts\" )) list (). then ( console . log ) encryptionContext = { stage : \"demo\" , purpose : \"simple demonstration\" , origin : \"us-east-2\" } store ( fs . createReadStream ( \"./store.js\" ), encryptionContext ). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key , { expectedContext : { stage : \"demo\" }, expectedContextKeys : [ \"purpose\" ] }). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL Typescript Node.JS CLI 1 2 3 4 5 6 7 8 9 10 11 ./cli.ts list ./cli.ts store ./store.js \\ -c \"stage:demo\" \\ -c \"purpose:simple demonstration\" \\ -c \"origin:us-east-2\" # Note the \"Key\" value ./cli.ts list # Note the \"reference\" value ./cli.ts retrieve $KeyOrReferenceValue \\ -c \"stage:demo\" \\ -k purpose Python 1 2 3 4 5 6 7 8 9 tox -e repl import document_bucket ops = document_bucket.initialize () context = { \"host\" : \"cloud9\" , \"shard\" : \"development\" , \"purpose\" : \"experimental\" } ops.list () ops.store ( b 'some data' , context ) for item in ops.list () : ops.retrieve ( item.partition_key, expected_context = context ) # Ctrl-D when finished to exit the REPL Explore Further Encryption context can provide different types of features and guardrails in your application logic. Consider these ideas for further exploration: Detecting Drift - context contents are stored on the DynamoDB item. S3 has object metadata that could also use the context pairs. How would you use the validated encryption context to validate and guardrail those two data sources? What could that feature add to your application? Meta-operations on Encryption Context - the encryption context is stored on the open-specification AWS Encryption SDK Message Format . Would it help your system to write tools to process the metadata -- such as the encryption context -- on the message format? DynamoDB Keys and Indexes - the Document Bucket adds composite indexes by context key. What about adding composite keys by key-value pairs? If you know a particular key should always be present in well-formed encrypted data, perhaps that should also be a Secondary Index ? Enforing EC Keys - If you know that there is a key that should always be present, and that you want to index on in DynamoDB, do you want to enforce that it's always present? You can extend the Cryptographic Materials Manager component in the AWS Encryption SDK to enforce this during cryptographic operations. Alarms and Monitoring - How can you leverage encryption context and CloudWatch Alarms for CloudTrail to monitor and protect your application? Next exercise That's it! You have officially completed the Busy Engineer's Document Bucket workshop. Proceed to Thank You and Closing for some parting thoughts and information.","title":"Working With Encryption Context"},{"location":"encryption-context/#exercise-3-working-with-encryption-context","text":"In this section, you will work with encryption context and explore its use in the Document Bucket and other applications.","title":"Exercise 3: Working With Encryption Context"},{"location":"encryption-context/#background","text":"The Busy Engineer's Document Bucket has metadata, called context , associated with each document. This meatadata is a set of key-value string pairs, associated with the item in DynamoDB, searchable there, and attached to the S3 object as well. One of the features AWS KMS and the AWS Encryption SDK both provide is called encryption context. At its core, encryption context is this metadata mapping: keys that are associated with context about the object, and values indicating information about what that context is. All the information in the map is non-secret, and is the basis for several feature integrations. One useful model for thinking about encryption context is as Assertions about the Five Ws : Who, What, Where, When, Why. For example: Who should have access to this decrypted data? What data is being decrypted? Where is the decryption happening? When is this data being used? Why is this data being decrypted?","title":"Background"},{"location":"encryption-context/#aws-kms-kms-operations-and-encryption-context","text":"AWS KMS allows you to specify an encryption context on kms:Encrypt . If you do so, you must provide the exact same encryption context on kms:Decrypt , or the operation will fail. (The match is case-sensitive, and key-value pairs are compared in an order independent way.) Behind the scenes, KMS is cryptographically binding the encryption context to the key material you are kms:Encrypt or kms:Decrypt ing as Additional Authenticated Data (AAD) . In short, this is non-secret data that must be identical (not tampered-with or incomplete), or decryption fails. This feature defends against risks from ciphertexts being tampered with, modified, or replaced -- intentionally or unintentionally. It both defends against an attacker replacing one ciphertext with another as well as problems like operational events. For example, if a bad deployment swaps us-west-2.cfg with eu-central-1.cfg on your fleets, having { fleet: us-west-2 } asserted in us-west-2.cfg 's encryption context will prevent it from accidentally being loaded by eu-central-1 .","title":"AWS KMS: KMS Operations and Encryption Context"},{"location":"encryption-context/#aws-kms-policy-and-audit-hooks","text":"KMS also makes the encryption context available to use in Key Policies and Grants. This means that you can use assertions you make about your data to control usage of your CMKs. Perhaps your eu-central-1 fleet should only ever be permitted to access encrypted data for { shard: europe } . You can write CMK policies that require { shard: europe } to be asserted about all cryptographic operations, so that KMS refuses to authorize an attempt to decrypt, say, { shard: north-america } . These options can help you secure your application and defend against both operational and security-related risks. Additionally, as part of the audit features that KMS provides, it logs the encryption context that was supplied with every operation. You can use this information to audit who was accessing what data and when, to detect anomalous call patterns, or to identify unexpected system states. What questions would you like to answer with CloudTrail Logs for your KMS operations? encryption context can help.","title":"AWS KMS: Policy and Audit Hooks"},{"location":"encryption-context/#the-aws-encryption-sdk","text":"The AWS Encryption SDK includes the encryption context as a core component. Encryption context may be supplied on encrypt -- it is optional, both for the Encryption SDK and for KMS, but strongly recommended. The Encryption SDK writes the encryption context in the encrypted message format. And on decrypt, the Encryption SDK validates the encryption context with KMS and returns the contents to you for you to make assertions about the contents. Using the Encryption SDK with KMS, you can use all of KMS' policy and audit features from encryption context, and use the Encryption SDK to make assertions to safeguard your application.","title":"The AWS Encryption SDK"},{"location":"encryption-context/#use-in-the-document-bucket","text":"So how can encryption context be useful in the Document Bucket? In this exercise, you will walk through a few examples of how leveraging encryption context can help you secure and audit your application, and even build some convenience features. The Document Bucket already has the context map available for operations. It writes the context to the DynamoDB records for objects as well, and generates searchable DynamoDB records for context keys, to let you find documents that have certain attributes. Now you will plumb that context through the AWS Encryption SDK, so that KMS and the Encryption SDK bind those properties as security assertions about your data. You will also add an assertion facility to ensure that your data is what you expect it to be when you call retrieve . What this means is that with this change, you will be able to use encryption context to defend against these kind of risks: DynamoDB record updates that create metadata mismatches between a document and its properties Swapping objects in S3 so that the data is no longer what it was expected to be Accidentally loading the wrong data blob Defending against objects being listed as having a certain context key / property when they actually do not Also, after this change, the contents of context will be available in audit log entries written by KMS, and you can now use that metadata in your Key Policies and Grants. Remember, encryption context is not secret!","title":"Use in the Document Bucket"},{"location":"encryption-context/#make-the-change","text":"","title":"Make the Change"},{"location":"encryption-context/#starting-directory","text":"If you just finished Using Multiple CMKs , you are all set. If you aren't sure, or want to catch up, jump into the encryption-context-start directory for the language of your choice. Java 1 cd ~/environment/workshop/java/encryption-context-start Typescript Node.JS 1 cd ~/environment/workshop/node-typescript/encryption-context-start JavaScript Node.JS 1 cd ~/environment/workshop/node-javascript/encryption-context-start Python 1 cd ~/environment/workshop/python/encryption-context-start","title":"Starting Directory"},{"location":"encryption-context/#step-1-set-encryption-context-on-encrypt","text":"Java 1 2 3 4 5 6 7 // Edit Api.java and find store(...) // ENCRYPTION-CONTEXT-START: Set Encryption Context on Encrypt CryptoResult < byte [], KmsMasterKey > encryptedMessage = awsEncryptionSdk . encryptData ( mkp , data , context ); DocumentBundle bundle = DocumentBundle . fromDataAndContext ( encryptedMessage . getResult (), context ); // Save your changes JavaScript Node.JS 1 2 3 4 5 6 7 // Edit store.js // ENCRYPTION-CONTEXT-COMPLETE: Set encryption context on Encrypt const Body = fileStream . pipe ( encryptStream ( encryptKeyring , { encryptionContext }) ); // Save your changes Typescript Node.JS 1 2 3 4 5 6 7 // Edit src/store.ts // ENCRYPTION-CONTEXT-COMPLETE: Set encryption context on Encrypt const Body = fileStream . pipe ( encryptStream ( encryptKeyring , { encryptionContext }) ); // Save your changes Python 1 2 3 4 5 6 7 8 9 10 # Edit src/document_bucket/api.py # Find the store(...) function, and add context to the encrypt call # ENCRYPTION-CONTEXT-START: Set encryption context on Encrypt encrypted_data , header = aws_encryption_sdk . encrypt ( source = data , key_provider = self . master_key_provider , encryption_context = context , ) # Save your changes","title":"Step 1: Set Encryption Context on Encrypt"},{"location":"encryption-context/#what-just-happened","text":"The Document Bucket context will now be supplied to the AWS Encryption SDK and AWS KMS as encryption context. If a non-empty key-value pair map is supplied to store , those key-value pairs will be used in encryption and decryption operations all the way through to KMS: The contents of context will appear in KMS audit logs. The contents of context will be availble to use in KMS Key Policies and Grants to make authorization decisions. The contents of context will be written to the Encryption SDK message. Supplying the exact-match contents of context will be required to decrypt any encrypted data keys. The contents of context will now be available on Decrypt to use in making assertions. Next you will update retrieve to use the encryption context on decrypt.","title":"What Just Happened"},{"location":"encryption-context/#step-2-use-encryption-context-on-decrypt","text":"Java 1 2 3 4 5 // Edit Api.java and find retrieve(...) // ENCRYPTION-CONTEXT-START: Use Encryption Context on Decrypt Map < String , String > actualContext = decryptedMessage . getEncryptionContext (); PointerItem pointer = PointerItem . fromKeyAndContext ( key , actualContext ); // Save your changes JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Edit retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( header ) { }) ); // Save your changes Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 // Edit src/retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( this : Writable , header : MessageHeader ) { }) ); // Save your changes Python 1 2 3 4 5 6 7 8 9 # Edit src/document_bucket/api.py # Find the retrieve(...) function, and use the Encryption SDK header's encryption # context to construct the DocumentBundle to return # ENCRYPTION-CONTEXT-START: Use encryption context on Decrypt return DocumentBundle . from_data_and_context ( plaintext , header . encryption_context ) # Save your changes","title":"Step 2: Use Encryption Context on Decrypt"},{"location":"encryption-context/#what-just-happened_1","text":"Now on decrypt, the validated encryption context from the Encryption SDK Message Format header will be passed back to the application. Any business logic that would benefit from using the encryption context data for making decisions can use the version bound and validated by the Encryption SDK and KMS. Next you will add a mechanism for the application to test assertions made in encryption context before working with the returned data.","title":"What Just Happened"},{"location":"encryption-context/#step-3-making-assertions","text":"Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Edit Api.java and find retrieve(...) // ENCRYPTION-CONTEXT-START: Making Assertions boolean allExpectedContextKeysFound = actualContext . keySet (). containsAll ( expectedContextKeys ); if (! allExpectedContextKeysFound ) { // Remove all of the keys that were found expectedContextKeys . removeAll ( actualContext . keySet ()); String error = String . format ( \"Expected context keys were not found in the actual encryption context! \" + \"Missing keys were: %s\" , expectedContextKeys . toString ()); throw new DocumentBucketException ( error , new NoSuchElementException ()); } boolean allExpectedContextFound = actualContext . entrySet (). containsAll ( expectedContext . entrySet ()); if (! allExpectedContextFound ) { Set < Map . Entry < String , String >> expectedContextEntries = expectedContext . entrySet (); expectedContextEntries . removeAll ( actualContext . entrySet ()); String error = String . format ( \"Expected context pairs were not found in the actual encryption context! \" + \"Missing pairs were: %s\" , expectedContextEntries . toString ()); throw new DocumentBucketException ( error , new NoSuchElementException ()); } // Save your work JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Edit retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( header ) { const { encryptionContext } = header ; const pairs = Object . entries ( expectedContext || {}); const keys = ( expectedContextKeys || []). slice (); if ( ! ( pairs . every (([ key , value ]) => encryptionContext [ key ] === value ) && keys . every ( key => Object . hasOwnProperty . call ( encryptionContext , key ) ) ) ) { this . emit ( \"error\" , new Error ( \"Encryption context does not match expected shape\" ) ); } }) ); // Save your changes Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // Edit src/retrieve.js return ( s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )) // ENCRYPTION-CONTEXT-COMPLETE: Making Assertions . once ( \"MessageHeader\" , function ( this : Writable , header : MessageHeader ) { const { encryptionContext } = header ; const pairs = Object . entries ( expectedContext || {}); const keys = ( expectedContextKeys || []). slice (); if ( ! ( pairs . every (([ key , value ]) => encryptionContext [ key ] === value ) && keys . every ( key => Object . hasOwnProperty . call ( encryptionContext , key ) ) ) ) { this . emit ( \"error\" , new Error ( \"Encryption context does not match expected shape\" ) ); } }) ); // Save your changes Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Edit src/document_bucket/api.py # Find the retrieve(...) function, and add some assertions about the contents # of the encryption context validated by the Encryption SDK # ENCRYPTION-CONTEXT-START: Making Assertions if not expected_context_keys <= header . encryption_context . keys (): error_msg = ( \"Encryption context assertion failed! \" f \"Expected all these keys: {expected_context_keys}, \" f \"but got {header.encryption_context}!\" ) raise AssertionError ( error_msg ) if not expected_context . items () <= header . encryption_context . items (): error_msg = ( \"Encryption context assertion failed! \" f \"Expected {expected_context}, \" f \"but got {header.encryption_context}!\" ) raise AssertionError ( error_msg )","title":"Step 3: Making Assertions"},{"location":"encryption-context/#what-just-happened_2","text":"retrieve will use its \"expected context keys\" argument to validate that all of those keys (with any associated values) are present in the encryption context. retrieve will also use its \"expected context\" argument to validate that the exact key-value pairs specified in expected context are present in the actual encryption context. If either of those assumptions is invalid, retrieve will raise an exception before returning the data. These assertions safeguard against accidentally returning unintended, corrupted, or tampered data to the application. Now the Document Bucket will use AWS KMS and the AWS Encryption SDK to ensure that the context metadata is consistent throughout the lifetime of the objects, resistant to tampering or corruption, and make the validated context available to the application logic to make additional business logic assertions safely.","title":"What Just Happened"},{"location":"encryption-context/#checking-your-work","text":"If you want to check your progress, or compare what you've done versus a finished example, check out the code in one of the -complete folders to compare. There is a -complete folder for each language. Java 1 cd ~/environment/workshop/exercises/java/encryption-context-complete Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript/encryption-context-complete JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript/encryption-context-complete Python 1 cd ~/environment/workshop/exercises/python/encryption-context-complete","title":"Checking Your Work"},{"location":"encryption-context/#try-it-out","text":"Now that you pass encryption context all the way through to KMS and validate it on return, what assertions do you want to make about your data? Here's some ideas for things to test: Expecting exact match of key-value pairs for keys like stage , shard , and source-fleet Expecting a set of keys to be present like submit-date and category Expecting an exact match of a subset of the supplied key-value pairs (e.g. only stage and shard , not source-fleet ) Doing the same for expected keys with any value Adding a constraint of a new key that you didn't supply at encryption time Adding a constraint with a different value, like stage=production Changing capitalization Using sorted versus unsorted mappings, such as java.util.SortedMap<K, V> in Java or collections.OrderedDict in Python There's a few simple suggestions to get you started in the snippets below. Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // To use the API programmatically, use this target to launch jshell mvn jshell:run /open startup.jsh import java.util.HashMap ; Api documentBucket = App.initializeDocumentBucket () ; HashMap<String, String> context = new HashMap<String, String> () ; context.put ( \"shard\" , \"test\" ) ; context.put ( \"app\" , \"document-bucket\" ) ; context.put ( \"origin\" , \"development\" ) ; documentBucket.list () ; documentBucket.store ( \"Store me in the Document Bucket!\" .getBytes () , context ) ; for ( PointerItem item : documentBucket.list ()) { DocumentBundle document = documentBucket.retrieve ( item.partitionKey () , context ) ; System.out.println ( document.toString ()) ; } // Ctrl+D to exit jshell // Or, to run logic that you write in App.java, use this target mvn compile JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) list (). then ( console . log ) encryptionContext = { stage : \"demo\" , purpose : \"simple demonstration\" , origin : \"us-east-2\" } store ( fs . createReadStream ( \"./store.js\" ), encryptionContext ). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key , { expectedContext : { stage : \"demo\" }, expectedContextKeys : [ \"purpose\" ] }). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL JavaScript Node.JS CLI 1 2 3 4 5 6 7 8 9 10 11 ./cli.js list ./cli.js store ./store.js \\ -c \"stage:demo\" \\ -c \"purpose:simple demonstration\" \\ -c \"origin:us-east-2\" # Note the \"Key\" value ./cli.js list # Note the \"reference\" value ./cli.js retrieve $KeyOrReferenceValue \\ -c \"stage:demo\" \\ -k purpose Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 node - r ts - node / register ;({ list } = require ( \"./src/list.ts\" )) ;({ store } = require ( \"./src/store.ts\" )) list (). then ( console . log ) encryptionContext = { stage : \"demo\" , purpose : \"simple demonstration\" , origin : \"us-east-2\" } store ( fs . createReadStream ( \"./store.js\" ), encryptionContext ). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key , { expectedContext : { stage : \"demo\" }, expectedContextKeys : [ \"purpose\" ] }). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL Typescript Node.JS CLI 1 2 3 4 5 6 7 8 9 10 11 ./cli.ts list ./cli.ts store ./store.js \\ -c \"stage:demo\" \\ -c \"purpose:simple demonstration\" \\ -c \"origin:us-east-2\" # Note the \"Key\" value ./cli.ts list # Note the \"reference\" value ./cli.ts retrieve $KeyOrReferenceValue \\ -c \"stage:demo\" \\ -k purpose Python 1 2 3 4 5 6 7 8 9 tox -e repl import document_bucket ops = document_bucket.initialize () context = { \"host\" : \"cloud9\" , \"shard\" : \"development\" , \"purpose\" : \"experimental\" } ops.list () ops.store ( b 'some data' , context ) for item in ops.list () : ops.retrieve ( item.partition_key, expected_context = context ) # Ctrl-D when finished to exit the REPL","title":"Try it Out"},{"location":"encryption-context/#explore-further","text":"Encryption context can provide different types of features and guardrails in your application logic. Consider these ideas for further exploration: Detecting Drift - context contents are stored on the DynamoDB item. S3 has object metadata that could also use the context pairs. How would you use the validated encryption context to validate and guardrail those two data sources? What could that feature add to your application? Meta-operations on Encryption Context - the encryption context is stored on the open-specification AWS Encryption SDK Message Format . Would it help your system to write tools to process the metadata -- such as the encryption context -- on the message format? DynamoDB Keys and Indexes - the Document Bucket adds composite indexes by context key. What about adding composite keys by key-value pairs? If you know a particular key should always be present in well-formed encrypted data, perhaps that should also be a Secondary Index ? Enforing EC Keys - If you know that there is a key that should always be present, and that you want to index on in DynamoDB, do you want to enforce that it's always present? You can extend the Cryptographic Materials Manager component in the AWS Encryption SDK to enforce this during cryptographic operations. Alarms and Monitoring - How can you leverage encryption context and CloudWatch Alarms for CloudTrail to monitor and protect your application?","title":"Explore Further"},{"location":"encryption-context/#next-exercise","text":"That's it! You have officially completed the Busy Engineer's Document Bucket workshop. Proceed to Thank You and Closing for some parting thoughts and information.","title":"Next exercise"},{"location":"getting-started/","text":"Getting Started These instructions will help you get started with the workshop and to bootstrap to your environment. Background In this section, you will prepare your AWS Environment to work with the Busy Engineer's Document Bucket. As you work through the workshop, you will gain familiarity with the core concepts required to use AWS KMS, the AWS Encryption SDK, and how to leverage features like multiple CMK support and Encryption Context to secure your application. In this exercise, we will walk you through setting up your environment, step by step. At the end of this exercise you will have completed the following: Deploy a CloudFormation stack to launch a Cloud9 IDE Launch the Cloud9 IDE that you will use to work with the rest of the workshop Launch resource stacks using the AWS Cloud Development Kit (CDK), including The BusyEngineersDocumentBucket stack, with your DynamoDB table and S3 bucket One CMK in one region, called Faythe, that you will use in encryption and decryption operations One CMK in another region, called Walter, that you will use in encryption and decryption operations Bootstrap the development environment in Cloud9 Start the workshop! Make the Change Sign in to your AWS Account for the workshop Make sure this is not a production account! This is a workshop for learning and experimentation. Don't put production at risk! Click this link to load the CloudFormation template for your Cloud9 IDE Click Create Stack to launch the stack. It will take 1-3 minutes to launch your Cloud9 IDE. Open the Cloud9 Console to find your Cloud9 IDE. You may need to wait a minute and refresh while CloudFormation spins up the resources There will be a blue tile with your IDE when it's ready. At the bottom of the tile, click Open IDE to launch Cloud9 Type cd ~/environment/workshop and hit Enter Execute make bootstrap and hit Enter to set up your workshop environment Wait until *** BOOTSTRAP COMPLETE *** appears to proceed Try it Out make bootstrap will take approximately 5 minutes. Thank you for your patience while it sets up the environment for you. If you are in a live workshop, this is good to run during the presentation. If you are working on your own, grab a cup of your favorite beverage while you wait. After make bootstrap completes and you see *** BOOTSTRAP COMPLETE *** , you will be ready to continue. At that point you will have: Deployed your workshop stacks using CDK Language environments for all of the workshop languages Close your Terminal window and open a new one ( Window -> New Terminal ) to pick up the changes make bootstrap installed Choose your language of choice for the workshop, and cd to its folder under exercises cd ~/environment/workshop/exercises/java for Java cd ~/environment/workshop/exercises/node-javascript for NodeJS cd ~/environment/workshop/exercises/python for Python Time to start coding! Explore Further Check out the ~/environment/workshop/cdk directory to see how the workshop resources are described using CDK Who are Faythe and Walter? Next exercise Now that you have your environment and language selected, you can Add the Encryption SDK .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"These instructions will help you get started with the workshop and to bootstrap to your environment.","title":"Getting Started"},{"location":"getting-started/#background","text":"In this section, you will prepare your AWS Environment to work with the Busy Engineer's Document Bucket. As you work through the workshop, you will gain familiarity with the core concepts required to use AWS KMS, the AWS Encryption SDK, and how to leverage features like multiple CMK support and Encryption Context to secure your application. In this exercise, we will walk you through setting up your environment, step by step. At the end of this exercise you will have completed the following: Deploy a CloudFormation stack to launch a Cloud9 IDE Launch the Cloud9 IDE that you will use to work with the rest of the workshop Launch resource stacks using the AWS Cloud Development Kit (CDK), including The BusyEngineersDocumentBucket stack, with your DynamoDB table and S3 bucket One CMK in one region, called Faythe, that you will use in encryption and decryption operations One CMK in another region, called Walter, that you will use in encryption and decryption operations Bootstrap the development environment in Cloud9 Start the workshop!","title":"Background"},{"location":"getting-started/#make-the-change","text":"Sign in to your AWS Account for the workshop Make sure this is not a production account! This is a workshop for learning and experimentation. Don't put production at risk! Click this link to load the CloudFormation template for your Cloud9 IDE Click Create Stack to launch the stack. It will take 1-3 minutes to launch your Cloud9 IDE. Open the Cloud9 Console to find your Cloud9 IDE. You may need to wait a minute and refresh while CloudFormation spins up the resources There will be a blue tile with your IDE when it's ready. At the bottom of the tile, click Open IDE to launch Cloud9 Type cd ~/environment/workshop and hit Enter Execute make bootstrap and hit Enter to set up your workshop environment Wait until *** BOOTSTRAP COMPLETE *** appears to proceed","title":"Make the Change"},{"location":"getting-started/#try-it-out","text":"make bootstrap will take approximately 5 minutes. Thank you for your patience while it sets up the environment for you. If you are in a live workshop, this is good to run during the presentation. If you are working on your own, grab a cup of your favorite beverage while you wait. After make bootstrap completes and you see *** BOOTSTRAP COMPLETE *** , you will be ready to continue. At that point you will have: Deployed your workshop stacks using CDK Language environments for all of the workshop languages Close your Terminal window and open a new one ( Window -> New Terminal ) to pick up the changes make bootstrap installed Choose your language of choice for the workshop, and cd to its folder under exercises cd ~/environment/workshop/exercises/java for Java cd ~/environment/workshop/exercises/node-javascript for NodeJS cd ~/environment/workshop/exercises/python for Python Time to start coding!","title":"Try it Out"},{"location":"getting-started/#explore-further","text":"Check out the ~/environment/workshop/cdk directory to see how the workshop resources are described using CDK Who are Faythe and Walter?","title":"Explore Further"},{"location":"getting-started/#next-exercise","text":"Now that you have your environment and language selected, you can Add the Encryption SDK .","title":"Next exercise"},{"location":"multi-cmk/","text":"Exercise 2: Adding Multi-CMK Support to the Document Bucket In this section, you will configure the AWS Encryption SDK to use multiple CMKs that reside in different regions. Background Now your Document Bucket will encrypt files when you store them, and will decrypt the files for you when you retrieve them. You're using one of your CMKs, Faythe. But what if you want to use multiple CMKs? You might want to use a partner team's CMK, so that they can access documents relevant to them. Perhaps you want the Document Bucket to have two independent regions to access the contents, for high availability, or to put the contents closer to the recipients. Configuring multiple CMKs this way does not require re-encryption of the document data. That's because the data is still encrypted with a single data key, used exclusively for that document. Configuring multiple CMKs causes the AWS Encryption SDK to encrypt that data key again using the additional CMKs, and store that additional version of the data key on the encrypted message format. As long as there is one available CMK to decrypt any encrypted version of the data key, the document will be accessible. (There are ways to configure the Encryption SDK to be more restrictive about which CMKs it will try -- but for now you'll start with the simple case.) There's many reasons why using more than one CMK can be useful. And in this exercise, you're going to see how to set that up with KMS and the Encryption SDK. You already have another CMK waiting to be used. When you deployed the Faythe CMK, you also deployed a second CMK, nicknamed Walter. In this exercise, we're going to configure Walter, and then use some scripts in the repository to add and remove permission to use each of Faythe and Walter. Doing so will change how your document is encrypted -- if you remove permission to both Faythe and Walter, you won't be able to encrypt or decrypt anymore! -- and let you observe how the system behavior changes when keys are accessible or inaccessible. Each attempt to use a CMK is checked against that CMK's permissions. An audit trail entry is also written to CloudTrail. Decryption attempts will continue for each version of the encrypted data key until the Encryption SDK either succeds at decrypting an encrypted data key with its associated CMK, or runs out of encrypted data keys to try. For encryption, the Encryption SDK will attempt to use every CMK it is configured to attempt to produce another encryption of that data key. You'll get to see all of this in action in just a minute, after a couple small code changes. Make the Change Starting Directory If you just finished Adding the Encryption SDK , you are all set. If you aren't sure, or want to catch up, jump into the multi-cmk-start directory for the language of your choice. Java 1 cd ~/environment/workshop/exercises/java/multi-cmk-start Typescript Node.JS 1 cd ~/environment/workshop/exercises/nodejs-typescript/multi-cmk-start JavaScript Node.JS 1 cd ~/environment/workshop/exercises/nodejs-javascript/multi-cmk-start Python 1 cd ~/environment/workshop/exercises/python/multi-cmk-start Step 1: Configure Walter Java 1 2 3 4 // Edit App.java String faytheCMK = state . contents . FaytheCMK ; // MULTI-CMK-START: Configure Walter String walterCMK = state . contents . WalterCMK ; JavaScript Node.JS 1 2 3 4 5 6 7 // Edit store.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); // Edit retrieve.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); Typescript Node.JS 1 2 3 4 5 6 7 // Edit src/store.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); // Edit retrieve.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); Python 1 2 3 4 # Edit src/document_bucket/__init__.py # MULTI-CMK-START: Configure Walter walter_cmk = state [ \"WalterCMK\" ] What Just Happened When you launched your workshop stacks in Getting Started , along with the Faythe CMK, you also launched a CMK called Walter. Walter's ARN was also plumbed through to the configuration state file that is set up for you by the workshop. Now that ARN is being pulled into a variable to use in the Encryption SDK configuration. Step 2: Add Walter to the CMKs to Use Java 1 2 3 4 // Edit App.java // MULTI-CMK-START: Add Walter to the CMKs to Use KmsMasterKeyProvider mkp = KmsMasterKeyProvider . builder (). withKeysForEncryption ( faytheCMK , walterCMK ). build (); JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Edit store.js // MULTI-CMK-START: Add the WalterCMK ... const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK , keyIds : [ walterCMK ] }); // Save and exit // Edit store.js // MULTI-CMK-START: Add the WalterCMK ... const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK , walterCMK ] }); // Save and exit Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Edit src/store.js // MULTI-CMK-START: Add the WalterCMK ... const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK , keyIds : [ walterCMK ] }); // Save and exit // Edit store.js // MULTI-CMK-START: Add the WalterCMK ... const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK , walterCMK ] }); // Save and exit Python 1 2 3 4 5 6 # Edit src/document_bucket/__init__.py # MULTI-CMK-START: Add Walter to the CMKs to Use cmk = [ faythe_cmk , walter_cmk ] # Save and exit What Just Happened In the previous exercise, you configured the Encryption SDK to use a list of CMKs that contained only Faythe. Configuring the Encryption SDK to also use Walter for encrypt, and to also try Walter for decrypt, required adding the ARN for Walter to the configuration list. Checking Your Work If you want to check your progress, or compare what you've done versus a finished example, check out the code in one of the -complete folders to compare. There is a -complete folder for each language. Java 1 cd ~/environment/workshop/exercises/java/multi-cmk-complete Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript/multi-cmk-complete JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript/multi-cmk-complete Python 1 cd ~/environment/workshop/exercises/python/multi-cmk-complete Try it Out Adding the Walter CMK to the list of CMKs that the application will (attempt) to use was a couple of lines of code, but has powerful implications. To help you explore the behavior of the system, there are some additional make targets to change the permissions configuration of Faythe and Walter. Using these targets, you can add and remove permission for the application to use Faythe and Walter to generate data keys, encrypt, and decrypt, and observe how the application behavior changes -- as well as what is logged to CloudTrail. In ~/environment/workshop/exercises , you'll find a Makefile with several targets for you to experiment with: make revoke_walter_grant will remove the Grant providing permissions to use Walter in the application make revoke_faythe_grant will remove the Grant providing permissions to use Faythe in the application make revoke_grants will remove the Grants for both CMKs make create_grants will add Grants to use either or both CMK, as needed You can observe the impact of changing Granted permissions by monitoring CloudTrail. Faythe is in us-east-2 , so check CloudTrail in us-east-2 Walter is in us-west-2 , so check CloudTrail in us-west-2 Try out combinations of Grant permissions for your application and watch how the behavior changes: Revoke permission to use Faythe, and watch calls move to Walter in CloudTrail and in your application With permission to use Faythe revoked, try retrieving an older document protected by Faythe Revoke permissions to both Faythe and Walter -- now operations fail Encrypt some data with both Faythe and Walter active, and revoke permission to either one -- notice that application operations continue to work Change the configuration order of Faythe and Walter, and watch how call patterns change to use the two CMKs Revoke permission to Walter, and encrypt some data with Faythe. Then, add permission back to Walter, revoke permission to use Faythe, and try to decrypt that data What other interesting access patterns can you imagine? Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // To use the API programmatically, use this target to launch jshell mvn jshell : run / open startup . jsh Api documentBucket = App . initializeDocumentBucket (); documentBucket . list (); documentBucket . store ( \"Store me in the Document Bucket!\" . getBytes ()); for ( PointerItem item : documentBucket . list ()) { DocumentBundle document = documentBucket . retrieve ( item . partitionKey ()); System . out . println ( document . toString ()); } // Ctrl+D to exit jshell // Use the make targets to change the Grants and see what happens! // To run logic that you write in App.java, use this target mvn compile JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) retrieve = require ( \"./retrieve\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Use the make targets to change the Grants and see what happens! // Ctrl-D when finished to exit the REPL JavaScript Node.JS CLI 1 2 3 4 5 6 7 ./cli.js list ./cli.js store ./store.js # Note the \"Key\" value ./cli.js list # Note the \"reference\" value ./cli.js retrieve $KeyOrReferenceValue # Use the make targets to change the grants and see what happens! Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 node - r ts - node / register ;({ list } = require ( \"./src/list.ts\" )) ;({ store } = require ( \"./src/store.ts\" )) retrieve = require ( \"./retrieve\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL // Use the make targets to change the Grants and see what happens! Typescript Node.JS CLI 1 2 3 4 5 6 7 ./cli.ts list ./cli.ts store ./store.js # Note the \"Key\" value ./cli.ts list # Note the \"reference\" value ./cli.ts retrieve $KeyOrReferenceValue # Use the make targets to change the grants and see what happens! Python 1 2 3 4 5 6 7 8 9 tox - e repl import document_bucket ops = document_bucket . initialize () ops . list () ops . store ( b 'some data' ) for item in ops . list (): print ( ops . retrieve ( item . partition_key )) # Use the make targets to change the grants and see what happens! # Ctrl-D when finished to exit the REPL Explore Further Want to dive into more content related to this exercise? Try out these links. AWS KMS: Key Grants AWS KMS: Key Policies AWS KMS: Cross-account CMK Usage Blog Post: How to decrypt ciphertexts in multiple regions with the AWS Encryption SDK in C Next exercise Ready for more? Next you will work with Encryption Context .","title":"Using Multiple CMKs"},{"location":"multi-cmk/#exercise-2-adding-multi-cmk-support-to-the-document-bucket","text":"In this section, you will configure the AWS Encryption SDK to use multiple CMKs that reside in different regions.","title":"Exercise 2: Adding Multi-CMK Support to the Document Bucket"},{"location":"multi-cmk/#background","text":"Now your Document Bucket will encrypt files when you store them, and will decrypt the files for you when you retrieve them. You're using one of your CMKs, Faythe. But what if you want to use multiple CMKs? You might want to use a partner team's CMK, so that they can access documents relevant to them. Perhaps you want the Document Bucket to have two independent regions to access the contents, for high availability, or to put the contents closer to the recipients. Configuring multiple CMKs this way does not require re-encryption of the document data. That's because the data is still encrypted with a single data key, used exclusively for that document. Configuring multiple CMKs causes the AWS Encryption SDK to encrypt that data key again using the additional CMKs, and store that additional version of the data key on the encrypted message format. As long as there is one available CMK to decrypt any encrypted version of the data key, the document will be accessible. (There are ways to configure the Encryption SDK to be more restrictive about which CMKs it will try -- but for now you'll start with the simple case.) There's many reasons why using more than one CMK can be useful. And in this exercise, you're going to see how to set that up with KMS and the Encryption SDK. You already have another CMK waiting to be used. When you deployed the Faythe CMK, you also deployed a second CMK, nicknamed Walter. In this exercise, we're going to configure Walter, and then use some scripts in the repository to add and remove permission to use each of Faythe and Walter. Doing so will change how your document is encrypted -- if you remove permission to both Faythe and Walter, you won't be able to encrypt or decrypt anymore! -- and let you observe how the system behavior changes when keys are accessible or inaccessible. Each attempt to use a CMK is checked against that CMK's permissions. An audit trail entry is also written to CloudTrail. Decryption attempts will continue for each version of the encrypted data key until the Encryption SDK either succeds at decrypting an encrypted data key with its associated CMK, or runs out of encrypted data keys to try. For encryption, the Encryption SDK will attempt to use every CMK it is configured to attempt to produce another encryption of that data key. You'll get to see all of this in action in just a minute, after a couple small code changes.","title":"Background"},{"location":"multi-cmk/#make-the-change","text":"","title":"Make the Change"},{"location":"multi-cmk/#starting-directory","text":"If you just finished Adding the Encryption SDK , you are all set. If you aren't sure, or want to catch up, jump into the multi-cmk-start directory for the language of your choice. Java 1 cd ~/environment/workshop/exercises/java/multi-cmk-start Typescript Node.JS 1 cd ~/environment/workshop/exercises/nodejs-typescript/multi-cmk-start JavaScript Node.JS 1 cd ~/environment/workshop/exercises/nodejs-javascript/multi-cmk-start Python 1 cd ~/environment/workshop/exercises/python/multi-cmk-start","title":"Starting Directory"},{"location":"multi-cmk/#step-1-configure-walter","text":"Java 1 2 3 4 // Edit App.java String faytheCMK = state . contents . FaytheCMK ; // MULTI-CMK-START: Configure Walter String walterCMK = state . contents . WalterCMK ; JavaScript Node.JS 1 2 3 4 5 6 7 // Edit store.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); // Edit retrieve.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); Typescript Node.JS 1 2 3 4 5 6 7 // Edit src/store.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); // Edit retrieve.js // MULTI-CMK-START: Add the WalterCMK const walterCMK = config . state . getWalterCMK (); Python 1 2 3 4 # Edit src/document_bucket/__init__.py # MULTI-CMK-START: Configure Walter walter_cmk = state [ \"WalterCMK\" ]","title":"Step 1: Configure Walter"},{"location":"multi-cmk/#what-just-happened","text":"When you launched your workshop stacks in Getting Started , along with the Faythe CMK, you also launched a CMK called Walter. Walter's ARN was also plumbed through to the configuration state file that is set up for you by the workshop. Now that ARN is being pulled into a variable to use in the Encryption SDK configuration.","title":"What Just Happened"},{"location":"multi-cmk/#step-2-add-walter-to-the-cmks-to-use","text":"Java 1 2 3 4 // Edit App.java // MULTI-CMK-START: Add Walter to the CMKs to Use KmsMasterKeyProvider mkp = KmsMasterKeyProvider . builder (). withKeysForEncryption ( faytheCMK , walterCMK ). build (); JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Edit store.js // MULTI-CMK-START: Add the WalterCMK ... const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK , keyIds : [ walterCMK ] }); // Save and exit // Edit store.js // MULTI-CMK-START: Add the WalterCMK ... const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK , walterCMK ] }); // Save and exit Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Edit src/store.js // MULTI-CMK-START: Add the WalterCMK ... const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK , keyIds : [ walterCMK ] }); // Save and exit // Edit store.js // MULTI-CMK-START: Add the WalterCMK ... const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK , walterCMK ] }); // Save and exit Python 1 2 3 4 5 6 # Edit src/document_bucket/__init__.py # MULTI-CMK-START: Add Walter to the CMKs to Use cmk = [ faythe_cmk , walter_cmk ] # Save and exit","title":"Step 2: Add Walter to the CMKs to Use"},{"location":"multi-cmk/#what-just-happened_1","text":"In the previous exercise, you configured the Encryption SDK to use a list of CMKs that contained only Faythe. Configuring the Encryption SDK to also use Walter for encrypt, and to also try Walter for decrypt, required adding the ARN for Walter to the configuration list.","title":"What Just Happened"},{"location":"multi-cmk/#checking-your-work","text":"If you want to check your progress, or compare what you've done versus a finished example, check out the code in one of the -complete folders to compare. There is a -complete folder for each language. Java 1 cd ~/environment/workshop/exercises/java/multi-cmk-complete Typescript Node.JS 1 cd ~/environment/workshop/exercises/node-typescript/multi-cmk-complete JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript/multi-cmk-complete Python 1 cd ~/environment/workshop/exercises/python/multi-cmk-complete","title":"Checking Your Work"},{"location":"multi-cmk/#try-it-out","text":"Adding the Walter CMK to the list of CMKs that the application will (attempt) to use was a couple of lines of code, but has powerful implications. To help you explore the behavior of the system, there are some additional make targets to change the permissions configuration of Faythe and Walter. Using these targets, you can add and remove permission for the application to use Faythe and Walter to generate data keys, encrypt, and decrypt, and observe how the application behavior changes -- as well as what is logged to CloudTrail. In ~/environment/workshop/exercises , you'll find a Makefile with several targets for you to experiment with: make revoke_walter_grant will remove the Grant providing permissions to use Walter in the application make revoke_faythe_grant will remove the Grant providing permissions to use Faythe in the application make revoke_grants will remove the Grants for both CMKs make create_grants will add Grants to use either or both CMK, as needed You can observe the impact of changing Granted permissions by monitoring CloudTrail. Faythe is in us-east-2 , so check CloudTrail in us-east-2 Walter is in us-west-2 , so check CloudTrail in us-west-2 Try out combinations of Grant permissions for your application and watch how the behavior changes: Revoke permission to use Faythe, and watch calls move to Walter in CloudTrail and in your application With permission to use Faythe revoked, try retrieving an older document protected by Faythe Revoke permissions to both Faythe and Walter -- now operations fail Encrypt some data with both Faythe and Walter active, and revoke permission to either one -- notice that application operations continue to work Change the configuration order of Faythe and Walter, and watch how call patterns change to use the two CMKs Revoke permission to Walter, and encrypt some data with Faythe. Then, add permission back to Walter, revoke permission to use Faythe, and try to decrypt that data What other interesting access patterns can you imagine? Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // To use the API programmatically, use this target to launch jshell mvn jshell : run / open startup . jsh Api documentBucket = App . initializeDocumentBucket (); documentBucket . list (); documentBucket . store ( \"Store me in the Document Bucket!\" . getBytes ()); for ( PointerItem item : documentBucket . list ()) { DocumentBundle document = documentBucket . retrieve ( item . partitionKey ()); System . out . println ( document . toString ()); } // Ctrl+D to exit jshell // Use the make targets to change the Grants and see what happens! // To run logic that you write in App.java, use this target mvn compile JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) retrieve = require ( \"./retrieve\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Use the make targets to change the Grants and see what happens! // Ctrl-D when finished to exit the REPL JavaScript Node.JS CLI 1 2 3 4 5 6 7 ./cli.js list ./cli.js store ./store.js # Note the \"Key\" value ./cli.js list # Note the \"reference\" value ./cli.js retrieve $KeyOrReferenceValue # Use the make targets to change the grants and see what happens! Typescript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 node - r ts - node / register ;({ list } = require ( \"./src/list.ts\" )) ;({ store } = require ( \"./src/store.ts\" )) retrieve = require ( \"./retrieve\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( r => { // Just storing the s3 key key = r . Key console . log ( r ) }) list (). then ( console . log ) retrieve ( key ). pipe ( process . stdout ) // Ctrl-D when finished to exit the REPL // Use the make targets to change the Grants and see what happens! Typescript Node.JS CLI 1 2 3 4 5 6 7 ./cli.ts list ./cli.ts store ./store.js # Note the \"Key\" value ./cli.ts list # Note the \"reference\" value ./cli.ts retrieve $KeyOrReferenceValue # Use the make targets to change the grants and see what happens! Python 1 2 3 4 5 6 7 8 9 tox - e repl import document_bucket ops = document_bucket . initialize () ops . list () ops . store ( b 'some data' ) for item in ops . list (): print ( ops . retrieve ( item . partition_key )) # Use the make targets to change the grants and see what happens! # Ctrl-D when finished to exit the REPL","title":"Try it Out"},{"location":"multi-cmk/#explore-further","text":"Want to dive into more content related to this exercise? Try out these links. AWS KMS: Key Grants AWS KMS: Key Policies AWS KMS: Cross-account CMK Usage Blog Post: How to decrypt ciphertexts in multiple regions with the AWS Encryption SDK in C","title":"Explore Further"},{"location":"multi-cmk/#next-exercise","text":"Ready for more? Next you will work with Encryption Context .","title":"Next exercise"},{"location":"thank-you-and-closing/","text":"","title":"Thank You and Closing"}]}