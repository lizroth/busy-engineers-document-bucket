{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"add-the-encryption-sdk/","text":"Exercise 1: Add the AWS Encryption SDK Background The Busy Engineer's Document Bucket is an example application meant to show some high-level examples of real world AWS patterns. This includes how to integrate client-side encryption using AWS KMS and the AWS Encryption SDK in application code. Right now, the Document Bucket supports storing files (or documents, or other blobs of data) in a private S3 bucket, and indexing them in DynamoDB. This allows Document Bucket users to share files with other users, or store them for retrieval later. The DynamoDB entries provide fast lookups to the content of the bucket, along with metadata context for each bucket item. This context allows storing additional information about the S3 item. Perhaps the origin user, the destination fleet, the project, or any other tag that would be useful to know without downloading and examining the item. DynamoDB is also configured to allow indexing on which documents have which keys. So, for example, it's a quick query to find out which documents in the bucket have been tagged with \"configuration\" as a piece of metadata about the object contents. Here's the API the Document Bucket supports: list : This operation queries DynamoDB for all entries for all items in the bucket, and their metadata. It returns the set of items that have been stored. store : This operation accepts a blob of bytes and a map of metadata context. It generates a unique identifier for the document. The identifier and associated metadata are written to DynamoDB. The bytes of the data are written to S3 under a key of that unique identifier. Any context metadata keys in DynamoDB are updated to include that new object identifier. retrieve : This operation accepts a unique identifier as an argument. First it looks that identifier up in DynamoDB and pulls the identifier and its context out. Then it retrieves that object from S3. It bundles these items together and returns them to the caller. search : This operation accepts a metadata key to search for. It then queries DynamoDB for the set of documents in the Document Bucket that have context matching that key. This operation then returns that set of document identifiers and their metadata. Once the desired document or documents have been identified with the returned metadata, the document identifiers can be passed to retrieve to actually fetch the documents. This is a start for sharing, storing, and searching documents of a variety of types. But what about sensitive documents? Or protecting, say, important configuration files from accidental corruption during storing or retrieving? Now you will add the AWS Encryption SDK to encrypt close to where the data originates: client-side encrypting the Document Bucket document before it is transmitted off of the host machine to the internet. You will use KMS to provide a data key for each document, using a CMK that you set up in Getting Started when you deployed your stacks. Make the Change Starting Directory Make sure you are in the exercises directory for the language of your choice: Java 1 cd ~/environment/workshop/exercises/java JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript Python 1 cd ~/environment/workshop/exercises/python cd into the add-esdk-start directory. Step 1: Add the ESDK Dependency Look for ADD-ESDK-START comments to help orient yourself in the code. Start by adding the Encryption SDK dependency to the code. JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 // Edit ./store.js const { encryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit // Edit ./retrieve.js const { decryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Edit src/document_bucket/__init__.py import aws_encryption_sdk # Save and exit # Edit src/document_bucket/api.py # ADD-ESDK-START import aws_encryption_sdk from aws_encryption_sdk import KMSMasterKeyProvider # Add a Master Key Provider to your __init__ # ADD-ESDK-START def __init__ ( self , bucket , table , master_key_provider : KMSMasterKeyProvider ): self . bucket = bucket self . table = table # ADD-ESDK-START self . master_key_provider = master_key_provider # Save and exit What Just Happened You just imported a dependency on the AWS Encryption SDK library in your code. You also changed the API to expect that a Keyring or Master Key Provider will be passed to your code to use in store and retrieve operations. Step 2: Add Encryption to store Now that you have the AWS Encryption SDK imported, start encrypting your data before storing it. JavaScript Node.JS 1 2 3 4 5 // Edit ./store.js const Body = fileStream . pipe ( encryptStream ( encryptKeyring )); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 # Edit src/document_bucket/api.py # Find the store function and edit it to add the Master Key Provider # and to write the encrypted data # ADD-ESDK-START encrypted_data , header = aws_encryption_sdk . encrypt ( source = data , key_provider = self . master_key_provider , ) ... self . _write_object ( encrypted_data , item ) What Just Happened The application will now encrypt data client-side with the AWS Encryption SDK and KMS before storing it. Now, before storing data in the Document Bucket, it uses the AWS Encryption SDK to: Request a new data key using your keyring or Master Key Provider Encrypt that data for you Return the encrypted data in the AWS Encryption SDK message format Extract the ciphertext to pass to the AWS S3 SDK to store in S3 Step 3: Add Decryption to retrieve Now that the application will encrypt data before storing it, it will need to decrypt the data before returning it to the caller. At least for the data to be useful, anyway. JavaScript Node.JS 1 2 3 4 5 6 7 8 // Edit retrieve.js return s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )); // Save and Exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/api.py # Find the retrieve function and edit it to add a call to decrypt the # encrypted data before returning it item = self . _get_pointer_item ( PointerQuery . from_key ( pointer_key )) # ADD-ESDK-START encrypted_data = self . _get_object ( item ) plaintext , header = aws_encryption_sdk . decrypt ( source = encrypted_data , key_provider = self . master_key_provider ) return DocumentBundle . from_data_and_context ( plaintext , item . context ) # Save and exit What Just Happened The application now decrypts data client-side as well. The data returned from S3 for retrieve is now encrypted. Before returning that data to the user, you added a call to the AWS Encryption SDK to decrypt the data. Under the hood, the Encryption SDK: Read the AWS Encryption SDK formatted encrypted message Called KMS to request to decrypt your message's encrypted data key using the Faythe CMK Used the decrypted data key to decrypt the message Returned the message plaintext and Encryption SDK headers to you Step 4: Plumb In Your Config Now that you have your dependencies declared and your code updated to encrypt and decrypt data, the final step is to pass through the configuration to the AWS Encryption SDK to start using your KMS CMKs to protect your data. JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Edit store.js const faytheCMK = config . state . getFaytheCMK (); const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK }); // Save and exit // Edit retrieve.js const faytheCMK = config . state . getFaytheCMK (); const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK ] }); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/__init__.py ... # ADD-ESDK-START # Pull configuration of KMS resources faythe_cmk = state [ \"FaytheCMK\" ] # And the Master Key Provider configuring how to use KMS cmk = [ faythe_cmk ] mkp = aws_encryption_sdk . KMSMasterKeyProvider ( key_ids = [ cmk ]) operations = DocumentBucketOperations ( bucket , table , mkp ) # Save and exit What Just Happened In Getting Started, you launched CloudFormation stacks for CMKs. One of these CMKs was nicknamed Faythe. As part of launching these templates, the CMK's Amazon Resource Name (ARN) was written to a configuration file on disk, the state variable that is loaded and parsed. Now Faythe's ARN is pulled into a variable, and used to initialize a keyring or master key provider that will use the Faythe CMK. That new keyring/master key provider is passed in to your API, and you are set to start encrypting and decrypting with KMS and the Encryption SDK. Checking Your Work Want to check your progress, or compare what you've done versus a finished example? Check out the code in one of the -complete folders to compare. 1 ~/ environment / workshop / exercises / java / add - esdk - complete JavaScript Node.JS 1 2 ~ /environment/workshop/exercises/node-javascript/add-esdk-complete/store.js ~ /environment/workshop/exercises/node-javascript/add-esdk-complete/retrieve.js Python 1 ~/ environment / workshop / exercises / python / add - esdk - complete Try it Out Now that the code is written, let's load it up and try it out. If you'd like to try a finished example, use your language's -complete directory as described above. JavaScript Node.JS 1 2 3 4 5 6 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( console . log ) list (). then ( console . log ) JavaScript Node.JS CLI 1 2 3 ./cli.js list ./cli.js store ./store.js ./cli.js list Python 1 2 3 4 5 6 7 tox - e repl import document_bucket ops = document_bucket . initialize () ops . list () ops . store ( b 'some data' ) ops . list () # Ctrl-D when finished to exit the REPL Explore Further TODO Retrieve TODO Examine TOML files TODO Generate and load files to store/retrieve Next exercise Now that you are encrypting and decrypting, how about adding Multiple CMKs ?","title":"Exercise 1: Add the AWS Encryption SDK"},{"location":"add-the-encryption-sdk/#exercise-1-add-the-aws-encryption-sdk","text":"","title":"Exercise 1: Add the AWS Encryption SDK"},{"location":"add-the-encryption-sdk/#background","text":"The Busy Engineer's Document Bucket is an example application meant to show some high-level examples of real world AWS patterns. This includes how to integrate client-side encryption using AWS KMS and the AWS Encryption SDK in application code. Right now, the Document Bucket supports storing files (or documents, or other blobs of data) in a private S3 bucket, and indexing them in DynamoDB. This allows Document Bucket users to share files with other users, or store them for retrieval later. The DynamoDB entries provide fast lookups to the content of the bucket, along with metadata context for each bucket item. This context allows storing additional information about the S3 item. Perhaps the origin user, the destination fleet, the project, or any other tag that would be useful to know without downloading and examining the item. DynamoDB is also configured to allow indexing on which documents have which keys. So, for example, it's a quick query to find out which documents in the bucket have been tagged with \"configuration\" as a piece of metadata about the object contents. Here's the API the Document Bucket supports: list : This operation queries DynamoDB for all entries for all items in the bucket, and their metadata. It returns the set of items that have been stored. store : This operation accepts a blob of bytes and a map of metadata context. It generates a unique identifier for the document. The identifier and associated metadata are written to DynamoDB. The bytes of the data are written to S3 under a key of that unique identifier. Any context metadata keys in DynamoDB are updated to include that new object identifier. retrieve : This operation accepts a unique identifier as an argument. First it looks that identifier up in DynamoDB and pulls the identifier and its context out. Then it retrieves that object from S3. It bundles these items together and returns them to the caller. search : This operation accepts a metadata key to search for. It then queries DynamoDB for the set of documents in the Document Bucket that have context matching that key. This operation then returns that set of document identifiers and their metadata. Once the desired document or documents have been identified with the returned metadata, the document identifiers can be passed to retrieve to actually fetch the documents. This is a start for sharing, storing, and searching documents of a variety of types. But what about sensitive documents? Or protecting, say, important configuration files from accidental corruption during storing or retrieving? Now you will add the AWS Encryption SDK to encrypt close to where the data originates: client-side encrypting the Document Bucket document before it is transmitted off of the host machine to the internet. You will use KMS to provide a data key for each document, using a CMK that you set up in Getting Started when you deployed your stacks.","title":"Background"},{"location":"add-the-encryption-sdk/#make-the-change","text":"","title":"Make the Change"},{"location":"add-the-encryption-sdk/#starting-directory","text":"Make sure you are in the exercises directory for the language of your choice: Java 1 cd ~/environment/workshop/exercises/java JavaScript Node.JS 1 cd ~/environment/workshop/exercises/node-javascript Python 1 cd ~/environment/workshop/exercises/python cd into the add-esdk-start directory.","title":"Starting Directory"},{"location":"add-the-encryption-sdk/#step-1-add-the-esdk-dependency","text":"Look for ADD-ESDK-START comments to help orient yourself in the code. Start by adding the Encryption SDK dependency to the code. JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 // Edit ./store.js const { encryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit // Edit ./retrieve.js const { decryptStream , KmsKeyringNode } = require ( \"@aws-crypto/client-node\" ); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Edit src/document_bucket/__init__.py import aws_encryption_sdk # Save and exit # Edit src/document_bucket/api.py # ADD-ESDK-START import aws_encryption_sdk from aws_encryption_sdk import KMSMasterKeyProvider # Add a Master Key Provider to your __init__ # ADD-ESDK-START def __init__ ( self , bucket , table , master_key_provider : KMSMasterKeyProvider ): self . bucket = bucket self . table = table # ADD-ESDK-START self . master_key_provider = master_key_provider # Save and exit","title":"Step 1: Add the ESDK Dependency"},{"location":"add-the-encryption-sdk/#what-just-happened","text":"You just imported a dependency on the AWS Encryption SDK library in your code. You also changed the API to expect that a Keyring or Master Key Provider will be passed to your code to use in store and retrieve operations.","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#step-2-add-encryption-to-store","text":"Now that you have the AWS Encryption SDK imported, start encrypting your data before storing it. JavaScript Node.JS 1 2 3 4 5 // Edit ./store.js const Body = fileStream . pipe ( encryptStream ( encryptKeyring )); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 # Edit src/document_bucket/api.py # Find the store function and edit it to add the Master Key Provider # and to write the encrypted data # ADD-ESDK-START encrypted_data , header = aws_encryption_sdk . encrypt ( source = data , key_provider = self . master_key_provider , ) ... self . _write_object ( encrypted_data , item )","title":"Step 2: Add Encryption to store"},{"location":"add-the-encryption-sdk/#what-just-happened_1","text":"The application will now encrypt data client-side with the AWS Encryption SDK and KMS before storing it. Now, before storing data in the Document Bucket, it uses the AWS Encryption SDK to: Request a new data key using your keyring or Master Key Provider Encrypt that data for you Return the encrypted data in the AWS Encryption SDK message format Extract the ciphertext to pass to the AWS S3 SDK to store in S3","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#step-3-add-decryption-to-retrieve","text":"Now that the application will encrypt data before storing it, it will need to decrypt the data before returning it to the caller. At least for the data to be useful, anyway. JavaScript Node.JS 1 2 3 4 5 6 7 8 // Edit retrieve.js return s3 . getObject ({ Bucket , Key }) . createReadStream () . pipe ( decryptStream ( decryptKeyring )); // Save and Exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/api.py # Find the retrieve function and edit it to add a call to decrypt the # encrypted data before returning it item = self . _get_pointer_item ( PointerQuery . from_key ( pointer_key )) # ADD-ESDK-START encrypted_data = self . _get_object ( item ) plaintext , header = aws_encryption_sdk . decrypt ( source = encrypted_data , key_provider = self . master_key_provider ) return DocumentBundle . from_data_and_context ( plaintext , item . context ) # Save and exit","title":"Step 3: Add Decryption to retrieve"},{"location":"add-the-encryption-sdk/#what-just-happened_2","text":"The application now decrypts data client-side as well. The data returned from S3 for retrieve is now encrypted. Before returning that data to the user, you added a call to the AWS Encryption SDK to decrypt the data. Under the hood, the Encryption SDK: Read the AWS Encryption SDK formatted encrypted message Called KMS to request to decrypt your message's encrypted data key using the Faythe CMK Used the decrypted data key to decrypt the message Returned the message plaintext and Encryption SDK headers to you","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#step-4-plumb-in-your-config","text":"Now that you have your dependencies declared and your code updated to encrypt and decrypt data, the final step is to pass through the configuration to the AWS Encryption SDK to start using your KMS CMKs to protect your data. JavaScript Node.JS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Edit store.js const faytheCMK = config . state . getFaytheCMK (); const encryptKeyring = new KmsKeyringNode ({ generatorKeyId : faytheCMK }); // Save and exit // Edit retrieve.js const faytheCMK = config . state . getFaytheCMK (); const decryptKeyring = new KmsKeyringNode ({ keyIds : [ faytheCMK ] }); // Save and exit Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Edit src/document_bucket/__init__.py ... # ADD-ESDK-START # Pull configuration of KMS resources faythe_cmk = state [ \"FaytheCMK\" ] # And the Master Key Provider configuring how to use KMS cmk = [ faythe_cmk ] mkp = aws_encryption_sdk . KMSMasterKeyProvider ( key_ids = [ cmk ]) operations = DocumentBucketOperations ( bucket , table , mkp ) # Save and exit","title":"Step 4: Plumb In Your Config"},{"location":"add-the-encryption-sdk/#what-just-happened_3","text":"In Getting Started, you launched CloudFormation stacks for CMKs. One of these CMKs was nicknamed Faythe. As part of launching these templates, the CMK's Amazon Resource Name (ARN) was written to a configuration file on disk, the state variable that is loaded and parsed. Now Faythe's ARN is pulled into a variable, and used to initialize a keyring or master key provider that will use the Faythe CMK. That new keyring/master key provider is passed in to your API, and you are set to start encrypting and decrypting with KMS and the Encryption SDK.","title":"What Just Happened"},{"location":"add-the-encryption-sdk/#checking-your-work","text":"Want to check your progress, or compare what you've done versus a finished example? Check out the code in one of the -complete folders to compare. 1 ~/ environment / workshop / exercises / java / add - esdk - complete JavaScript Node.JS 1 2 ~ /environment/workshop/exercises/node-javascript/add-esdk-complete/store.js ~ /environment/workshop/exercises/node-javascript/add-esdk-complete/retrieve.js Python 1 ~/ environment / workshop / exercises / python / add - esdk - complete","title":"Checking Your Work"},{"location":"add-the-encryption-sdk/#try-it-out","text":"Now that the code is written, let's load it up and try it out. If you'd like to try a finished example, use your language's -complete directory as described above. JavaScript Node.JS 1 2 3 4 5 6 node list = require ( \"./list.js\" ) store = require ( \"./store.js\" ) list (). then ( console . log ) store ( fs . createReadStream ( \"./store.js\" )). then ( console . log ) list (). then ( console . log ) JavaScript Node.JS CLI 1 2 3 ./cli.js list ./cli.js store ./store.js ./cli.js list Python 1 2 3 4 5 6 7 tox - e repl import document_bucket ops = document_bucket . initialize () ops . list () ops . store ( b 'some data' ) ops . list () # Ctrl-D when finished to exit the REPL","title":"Try it Out"},{"location":"add-the-encryption-sdk/#explore-further","text":"TODO Retrieve TODO Examine TOML files TODO Generate and load files to store/retrieve","title":"Explore Further"},{"location":"add-the-encryption-sdk/#next-exercise","text":"Now that you are encrypting and decrypting, how about adding Multiple CMKs ?","title":"Next exercise"},{"location":"getting-started/","text":"Getting Started Background In this section, you will prepare your AWS Environment to work with the Busy Engineer's Document Bucket. As you work through the workshop, you will gain familiarity with the core concepts required to use AWS KMS, the AWS Encryption SDK, and how to leverage features like multiple CMK support and Encryption Context to secure your application. In this exercise, we will walk you through setting up your environment, step by step. At the end of this exercise you will have completed the following: Deploy a CloudFormation stack to launch a Cloud9 IDE Launch the Cloud9 IDE that you will use to work with the rest of the workshop Launch resource stacks using the AWS Cloud Development Kit (CDK), including The BusyEngineersDocumentBucket stack, with your DynamoDB table and S3 bucket One CMK in one region, called Faythe , that you will use in encryption and decryption operations One CMK in another region, called Walter , that you will use in encryption and decryption operations Bootstrap the development environment in Cloud9 Start the workshop! Make the Change Sign in to your AWS Account for the workshop Make sure this is not a production account! This is a workshop for learning and experimentation. Don't put production at risk! Click this link to load the CloudFormation template for your Cloud9 IDE Click Create Stack to launch the stack. It will take 1-3 minutes to launch your Cloud9 IDE. Open the Cloud9 Console to find your Cloud9 IDE. You may need to wait a minute and refresh while CloudFormation spins up the resources There will be a blue tile with your IDE when it's ready. At the bottom of the tile, click Open IDE to launch Cloud9 Type cd ~/environment/workshop and hit Enter Execute make bootstrap and hit Enter to set up your workshop environment Wait until *** BOOTSTRAP COMPLETE *** appears to proceed Try it Out make bootstrap will take approximately 5 minutes. Thank you for your patience while it sets up the environment for you. If you are in a live workshop, this is good to run during the presentation. If you are working on your own, grab a cup of your favorite beverage while you wait. After make bootstrap completes, you will have: Deployed your workshop stacks using CDK Language environments for all of the workshop languages Close your Terminal window and open a new one ( Window -> New Terminal ) to pick up the changes make bootstrap installed Choose your language of choice for the workshop, and cd to its folder under exercises cd ~/environment/workshop/exercises/java for Java cd ~/environment/workshop/exercises/node-javascript for NodeJS cd ~/environment/workshop/exercises/python for Python Time to start coding! Explore Further Check out the ~/environment/workshop/cdk directory to see how the workshop resources are described using CDK Who are Faythe and Walter, anyway? And the other characters you may encounter as you explore. Next exercise Now that you have your environment and language selected, you can Add the Encryption SDK .","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#background","text":"In this section, you will prepare your AWS Environment to work with the Busy Engineer's Document Bucket. As you work through the workshop, you will gain familiarity with the core concepts required to use AWS KMS, the AWS Encryption SDK, and how to leverage features like multiple CMK support and Encryption Context to secure your application. In this exercise, we will walk you through setting up your environment, step by step. At the end of this exercise you will have completed the following: Deploy a CloudFormation stack to launch a Cloud9 IDE Launch the Cloud9 IDE that you will use to work with the rest of the workshop Launch resource stacks using the AWS Cloud Development Kit (CDK), including The BusyEngineersDocumentBucket stack, with your DynamoDB table and S3 bucket One CMK in one region, called Faythe , that you will use in encryption and decryption operations One CMK in another region, called Walter , that you will use in encryption and decryption operations Bootstrap the development environment in Cloud9 Start the workshop!","title":"Background"},{"location":"getting-started/#make-the-change","text":"Sign in to your AWS Account for the workshop Make sure this is not a production account! This is a workshop for learning and experimentation. Don't put production at risk! Click this link to load the CloudFormation template for your Cloud9 IDE Click Create Stack to launch the stack. It will take 1-3 minutes to launch your Cloud9 IDE. Open the Cloud9 Console to find your Cloud9 IDE. You may need to wait a minute and refresh while CloudFormation spins up the resources There will be a blue tile with your IDE when it's ready. At the bottom of the tile, click Open IDE to launch Cloud9 Type cd ~/environment/workshop and hit Enter Execute make bootstrap and hit Enter to set up your workshop environment Wait until *** BOOTSTRAP COMPLETE *** appears to proceed","title":"Make the Change"},{"location":"getting-started/#try-it-out","text":"make bootstrap will take approximately 5 minutes. Thank you for your patience while it sets up the environment for you. If you are in a live workshop, this is good to run during the presentation. If you are working on your own, grab a cup of your favorite beverage while you wait. After make bootstrap completes, you will have: Deployed your workshop stacks using CDK Language environments for all of the workshop languages Close your Terminal window and open a new one ( Window -> New Terminal ) to pick up the changes make bootstrap installed Choose your language of choice for the workshop, and cd to its folder under exercises cd ~/environment/workshop/exercises/java for Java cd ~/environment/workshop/exercises/node-javascript for NodeJS cd ~/environment/workshop/exercises/python for Python Time to start coding!","title":"Try it Out"},{"location":"getting-started/#explore-further","text":"Check out the ~/environment/workshop/cdk directory to see how the workshop resources are described using CDK Who are Faythe and Walter, anyway? And the other characters you may encounter as you explore.","title":"Explore Further"},{"location":"getting-started/#next-exercise","text":"Now that you have your environment and language selected, you can Add the Encryption SDK .","title":"Next exercise"}]}